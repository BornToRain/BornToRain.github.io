[{"id":"40b7a7c125f13d8e0f75168a47558e43","title":"从零开始撸框架(5)-与Vert.x集成(一)","content":"前两章我们分别讲完了类、配置,让框架有了骨架.接下来几章我们要实现类、配置与Vert.x集成,让框架跑在Vert.x中.\n由于接下来会设计到对外提供web服务了,篇幅会比较长.这里我决定分篇,第一篇先把大体的讲完,剩下几篇再讲web方面的细节.\nVert.x原始使用方式样例来自于Vert.x官网\n编写Verticleimport io.vertx.core.AbstractVerticle;\n\npublic class Server extends AbstractVerticle &#123;\n  public void start() &#123;\n    vertx.createHttpServer().requestHandler(req -> &#123;\n      req.response()\n        .putHeader(\"content-type\", \"text/plain\")\n        .end(\"Hello from Vert.x!\");\n    &#125;).listen(8080);\n  &#125;\n&#125;\n\n\n部署Verticlepublic class HelloWorld &#123;\n  public static void main() &#123;\n    Vertx vertx = Vertx.vertx();\n    vertx.deployVerticle(Server.class.getName());\n  &#125;\n&#125;\n\n这里贴出来方便参考,下面开始与Vert.x的集成.\n\nVert.x集成基类辅助类工具集成中,不管是 Eventloop 还是 Worker 都会用到一些重复的方法,只是部分参数不同,我们把它做成工具类.Verticles.java\npackage org.btr.ygo.core.kit;\n\nimport io.vertx.core.DeploymentOptions;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.eventbus.DeliveryOptions;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.constant.Const;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * Vert.x Vertcile部署\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class Verticles &#123;\n  // value - verticle id\n  private static final Map&lt;Class&lt;?>, String> VERTICLES = new HashMap&lt;>();\n  private static String flag(boolean isWorker) &#123;\n    return isWorker ? Const.WORKER : Const.EVENTLOOP;\n  &#125;\n  public static void deploy(Vertx vertx, DeploymentOptions options, Class&lt;?> cls) &#123;\n    val name = cls.getName();\n    val flag = flag(options.isWorker());\n    vertx.deployVerticle(cls.getName(), options, ar -> &#123;\n      val id = ar.result();\n      val instances = options.getInstances();\n      if (ar.succeeded()) &#123;\n        log.info(Console.DEPLOYED_S, flag, name, instances, id);\n        VERTICLES.put(cls, id);\n      &#125;\n      else &#123;\n        val cause = ar.cause();\n        if (Objects.nonNull(cause)) cause.printStackTrace();\n        val msg = Objects.isNull(cause) ? null : cause.getMessage();\n        log.warn(Console.DEPLOYED_F, flag, name, id, instances, msg);\n      &#125;\n    &#125;);\n  &#125;\n  public static void undeploy(Vertx vertx, Class&lt;?> cls, String flag) &#123;\n    val id = VERTICLES.get(cls);\n    val name = cls.getName();\n    vertx.undeploy(id, ar -> &#123;\n      if (ar.succeeded()) log.info(Console.UNDEPLOYED_S, flag, name, id);\n      else &#123;\n        val cause = ar.cause();\n        if (Objects.nonNull(cause)) cause.printStackTrace();\n        val msg = Objects.isNull(cause) ? null : cause.getMessage();\n        log.warn(Console.UNDEPLOYED_F, flag, name, id, msg);\n      &#125;\n    &#125;);\n  &#125;\n  public static DeliveryOptions delivery() &#123;\n    return new DeliveryOptions();\n  &#125;\n&#125;\n\n类、配置当然也会用到我们之前加载好的类、配置.Trunk.java\npublic final class Trunk &#123;\n  ...\n  // 所有@Eventloop类\n  public static final Set&lt;Class&lt;?>> EVENTLOOPS = new HashSet&lt;>();\n  // 所有@Worker类\n  public static final Set&lt;Class&lt;?>> WORKERS = new HashSet&lt;>();\n  // 所有Vert.x EventBus上的对象\n  public static final Set&lt;Receipt> RECEIPTS = new HashSet&lt;>();\n  ...\n&#125;\nDeck.java\npublic final class Deck &#123;\n  ...\n  // 所有http服务配置\n  public static final Map&lt;Integer, Server> HTTP_SERVERS = new HashMap&lt;>();\n  // 所有tcp服务配置\n  public static final Map&lt;Integer, Server> NET_SERVERS = new HashMap&lt;>();\n  ...\n&#125;\nReflect.java\npublic final class Reflect &#123;\n  ...\n  private static final Map&lt;Class&lt;?>, MethodAccess> METHODS = new HashMap&lt;>();\n  // 反射执行对应的方法\n  public static &lt;T> T invokeMethod(Object instance, String name, Object... args) &#123;\n    return Fn.ensureRun(() -> &#123;\n      val instanceCls = instance.getClass();\n      val access = Fn.pool(METHODS, instanceCls, () -> MethodAccess.get(instanceCls));\n      return (T) access.invoke(instance, name, args);\n    &#125;, instance, name);\n  &#125;\n&#125;\n\n本体IActor是框架与Vert.x的连接桥梁,子类继承该类就可以获得Vert.x框架中的Vert.x对象.\nIActor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.Vertx;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface IActor &#123;\n  void integration(Vertx vertx);\n&#125;\n\nVert.x中最小工作单位Verticle为一个类,它的配置参数io.vertx.core.DeploymentOptions就是根据该类获取的,这里我们可以得出一个Verticle配置参数提取基类.\nIExtractor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.DeploymentOptions;\n\n/**\n * 根据类名获取相应的配置\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface IExtractor &#123;\n  DeploymentOptions extract(Class&lt;?> cls);\n&#125;\n\nVert.x通信是通过eventbus交互的,这里我们也抽象出一个基类,后续可以实现异步(Future)、同步(Sync)、响应式(Rx)应答,当前我们仅实现Future.\nIReplier.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.Future;\nimport io.vertx.core.eventbus.Message;\nimport org.btr.ygo.core.kit.Trunk;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface IReplier &#123;\n  // 定义一个map,用于表驱动选取对应的应答模式,默认是Future.\n  Map&lt;Class&lt;?>, IReplier> HANDLES = new HashMap&lt;>() &#123;&#123;\n    put(Future.class, Trunk.singleton(FutureReplier.class));\n  &#125;&#125;;\n  static IReplier get(Class&lt;?> key) &#123;\n    return HANDLES.getOrDefault(key, Trunk.singleton(FutureReplier.class));\n  &#125;\n  void reply(Object proxy, Method method, Message&lt;Object> message);\n&#125;\n\nFutureReplier.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.Future;\nimport io.vertx.core.eventbus.Message;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.kit.Reflect;\nimport org.btr.ygo.core.kit.Verticles;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class FutureReplier implements IReplier &#123;\n  @Override\n  public void reply(Object proxy, Method method, Message&lt;Object> message) &#123;\n    // 因为是Future响应,返回值的形式是Future&lt;?>,光靠method.getReturnType()是拿不到具体泛型的.\n    val retType = method.getGenericReturnType();\n    log.info(Console.REPLY, getClass(), retType, false);\n    // 反射执行方法\n    Reflect.&lt;Future&lt;?>>invokeMethod(proxy, method.getName(), message)\n      // 执行完成,开始应答.\n      .onComplete(ar -> message.reply(ar.result(), Verticles.delivery()));\n  &#125;\n&#125;\n\n\nEventloop集成本体EventloopExtractor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.DeploymentOptions;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Eventloop;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Fn;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Eventloop类的Verticle参数提取\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class EventloopExtractor implements IExtractor &#123;\n  private static final Map&lt;Class&lt;?>, DeploymentOptions> OPTIONS = new HashMap&lt;>();\n  @Override\n  public DeploymentOptions extract(Class&lt;?> cls) &#123;\n    log.info(Console.DEPLOY, Const.EVENTLOOP, cls.getName());\n    return Fn.pool(OPTIONS, cls, () -> extractValue(cls));\n  &#125;\n  private DeploymentOptions extractValue(Class&lt;?> cls) &#123;\n    val anno = cls.getAnnotation(Eventloop.class);\n    val options =\n      new DeploymentOptions().setHa(anno.ha()).setInstances(anno.instances()).setWorker(false);\n    if (!OPTIONS.isEmpty()) &#123;\n      val latest = OPTIONS.getOrDefault(cls, new DeploymentOptions());\n      val oldest = options.toJson();\n      oldest.mergeIn(latest.toJson(), true);\n      return new DeploymentOptions(oldest);\n    &#125;\n    log.info(Console.DEPLOYED, Const.EVENTLOOP, options.getInstances(), options.isHa(),\n      options.toJson());\n    return options;\n  &#125;\n&#125;\n\nEventloopActor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.Vertx;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.constant.EventloopType;\nimport org.btr.ygo.core.kit.Trunk;\nimport org.btr.ygo.core.kit.Verticles;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * eventloop集合与Vert.x集成\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class EventloopActor implements IActor &#123;\n  // 这里定义一个集合,因为eventloop目前总共有三类, http、tcp、sock.\n  public static final Map&lt;EventloopType, Class&lt;?>> EVENTLOOPS = new HashMap&lt;>();\n  @Override\n  public void integration(Vertx vertx) &#123;\n    // 配置提取器\n    val extractor = Trunk.&lt;EventloopExtractor>singleton(EventloopExtractor.class);\n    // 循环作为Verticle部署到Vert.x中\n    EVENTLOOPS.forEach((type, cls) -> Verticles.deploy(vertx, extractor.extract(cls), cls));\n    // 钩子,优雅从Vert.x中卸载对应的Verticle.\n    Runtime.getRuntime().addShutdownHook(new Thread(\n      () -> EVENTLOOPS.forEach((type, cls) -> Verticles.undeploy(vertx, cls, Const.EVENTLOOP))));\n  &#125;\n&#125;\n\nEventloop类型分为http、tcp、sock分类,这里我们实现一个http.\nhttp实现http我们只实现任务调度部分.\nhttp非vertx-core内容,这里我们新建一个web模块,接下来web方面内容都在该模块下写.\nbuild.gradle(web模块下)\ndependencies &#123;\n  &#x2F;&#x2F; 依赖核心组件\n  compile project(&quot;:core&quot;)\n  &#x2F;&#x2F; 追加vertx-web\n  compile &quot;io.vertx:vertx-web:$vertxVersion&quot;\n&#125;\n\nhttp配置新建两个Java文件,一个是配置对象,一个是继承自前两章的IConfig接口来实现配置读取.\n配置对象Server.java\npackage org.btr.ygo.web.config;\n\nimport io.vertx.core.json.JsonObject;\nimport lombok.AccessLevel;\nimport lombok.Data;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.FieldDefaults;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Data\n@Accessors(chain = true)\n@FieldDefaults(level = AccessLevel.PRIVATE)\npublic class Server &#123;\n  // HttpServerOptions NetServerOptions\n  JsonObject options;\n  String type;\n  String name;\n&#125;\n\n配置读取ServerConfig.java\npackage org.btr.ygo.web.config;\n\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.config.IConfig;\nimport org.btr.ygo.core.config.YgoConfig;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Trunk;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 从配置文件中读取Web服务配置\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class ServerConfig implements IConfig&lt;Map&lt;Integer, Server>> &#123;\n  @Override\n  public Map&lt;Integer, Server> read() &#123;\n    val config = Trunk.&lt;YgoConfig>singleton(YgoConfig.class).read();\n    return read(config.getJsonObject(Const.VERTX).getJsonArray(Const.SERVER));\n  &#125;\n  // 根据端口分组\n  private Map&lt;Integer, Server> read(JsonArray xs) &#123;\n    val map = new HashMap&lt;Integer, Server>();\n    xs.forEach(d -> &#123;\n      val json = JsonObject.mapFrom(d);\n      val options = json.getJsonObject(Const.OPTIONS);\n      val port = options.getInteger(Const.PORT, 8080);\n      val value = new Server().setName(json.getString(\"name\")).setType(json.getString(\"type\"))\n        .setOptions(options);\n      map.put(port, value);\n    &#125;);\n    return map;\n  &#125;\n&#125;\n\nhttp本体EventloopHttpActor.java\npackage org.btr.ygo.web.actor;\n\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.http.HttpServerOptions;\nimport io.vertx.ext.web.Router;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Eventloop;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.web.config.Server;\nimport org.btr.ygo.web.constant.Console;\nimport org.btr.ygo.web.kit.Deck;\nimport org.btr.ygo.web.kit.Network;\n\n/**\n * eventloop的http实现\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@Eventloop\npublic final class EventloopHttpActor extends AbstractVerticle &#123;\n  @Override\n  public void start() throws Exception &#123;\n    // http服务集合\n    Deck.HTTP_SERVERS.forEach((port, config) -> &#123;\n      // 获取路由\n      val router = Router.router(vertx);\n      server(router, port, config);\n    &#125;);\n  &#125;\n  // 发布http服务\n  private void server(Router router, Integer port, Server config) &#123;\n    val options = new HttpServerOptions(config.getOptions());\n    vertx.createHttpServer(options).requestHandler(router).listen();\n    // 发布api地址\n    val path = \"http://\" + Network.getIPv4() + Const.COLON + port + Const.SLASH;\n    log.info(Console.SERVER, getClass().getSimpleName(), Const.HTTP, path);\n  &#125;\n&#125;\n\n\nWorker集成本体这一块同Eventloop部分,不多赘述.\nWorkerExtractor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.DeploymentOptions;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Worker;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Fn;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class WorkerExtractor implements IExtractor &#123;\n  private static final Map&lt;Class&lt;?>, DeploymentOptions> OPTIONS = new HashMap&lt;>();\n  @Override\n  public DeploymentOptions extract(Class&lt;?> cls) &#123;\n    log.info(Console.DEPLOY, Const.WORKER, cls.getName());\n    return Fn.pool(OPTIONS, cls, () -> extractValue(cls));\n  &#125;\n  private DeploymentOptions extractValue(Class&lt;?> cls) &#123;\n    val anno = cls.getAnnotation(Worker.class);\n    val options =\n      new DeploymentOptions().setHa(anno.ha()).setInstances(anno.instances()).setWorker(true);\n    if (!OPTIONS.isEmpty()) &#123;\n      val latest = OPTIONS.getOrDefault(cls, new DeploymentOptions());\n      val oldest = options.toJson();\n      oldest.mergeIn(latest.toJson(), true);\n      return new DeploymentOptions(oldest);\n    &#125;\n    log.info(Console.DEPLOYED, Const.WORKER, options.getInstances(), options.isHa(), options.toJson());\n    return options;\n  &#125;\n&#125;\n\nWorkerActor.java\npackage org.btr.ygo.core.actor;\n\nimport io.vertx.core.Vertx;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Trunk;\nimport org.btr.ygo.core.kit.Verticles;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class WorkerActor implements IActor&#123;\n  @Override\n  public void integration(Vertx vertx) &#123;\n    val extractor = Trunk.&lt;WorkerExtractor>singleton(WorkerExtractor.class);\n    Trunk.WORKERS.forEach(cls -> Verticles.deploy(vertx, extractor.extract(cls), cls));\n    Runtime.getRuntime().addShutdownHook(\n      new Thread(() -> Trunk.WORKERS.forEach(cls -> Verticles.undeploy(vertx, cls, Const.WORKER))));\n  &#125;\n&#125;\n\nhttp实现http的请求调度eventloop已经实现,这里我们只需要实现http的请求处理.\nhttp本体WorkerHttpActor.java\npackage org.btr.ygo.web.actor;\n\nimport io.vertx.core.AbstractVerticle;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.actor.IReplier;\nimport org.btr.ygo.core.annotations.Worker;\nimport org.btr.ygo.core.kit.Trunk;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@Worker\npublic final class WorkerHttpActor extends AbstractVerticle &#123;\n  @Override\n  public void start() throws Exception &#123;\n    // 所有的Vert.x消息\n    Trunk.RECEIPTS.forEach(data -> &#123;\n      val method = data.getMethod();\n      // 根据返回值类型,Future Object决定应答模式.\n      val replier = IReplier.get(method.getReturnType());\n      // Vert.x EventBus上根据地址开始消费消息并响应.\n      vertx.eventBus().consumer(data.getAddr(), msg -> replier.reply(data.getProxy(), method, msg));\n    &#125;);\n  &#125;\n&#125;\n\n\n总结这一篇我们大体上实现了Eventloop、Worker类、配置与Vert.x的集成,让这些玩意转成Vert.x能看懂的Verticle运行起来.\n但是细心的你应该也发现了,上文我仅仅实现了Worker对于消息的消费,并没实现Eventloop对于消息的转发.\n因为Eventloop涉及到Vert.x中的Router,这一块东西比较大,下面我会拆成几篇来细讲.\n","slug":"从零开始撸框架(5)-与Vert.x集成(一)","date":"2021-05-07T00:27:12.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java,代理模式","author_index":"因雨而生"},{"id":"45dcae5ccfe9e8f63cc7cbe584bb9d7a","title":"从零开始撸框架(4)-配置读取器","content":"到目前为止,框架已经支持了 工厂 、 Bean分组 、 依赖注入 ,这一章我们来实现框架配置的读取.\n配置读取基类老样子,我们还是先定义一个读取基类,方便后续子类扩展.\nIConfig.java\npackage org.btr.ygo.core.config;\n\n/**\n * 读取配置文件\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface IConfig&lt;T> &#123;\n  T read();\n&#125;\n\n辅助类配置加载肯定会涉及到IO流IO.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.util.Objects;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class IO &#123;\n  // 确保能获取输入流\n  public static InputStream ensureRead(String filename) &#123;\n    return Fn.ensureRun(() -> &#123;\n      val file = new File(filename);\n      var in = Fn.ensureRun(file.exists() &amp;&amp; file.isFile(),\n        // 1. 直接读文件\n        () -> new FileInputStream(file),\n        // 2. 环境上下文\n        () -> Thread.currentThread().getContextClassLoader().getResourceAsStream(filename));\n      // 3. 当前类加载器\n      if (Objects.isNull(in)) in = IO.class.getResourceAsStream(filename);\n      // 4. 类加载器\n      if (Objects.isNull(in)) in = ClassLoader.getSystemResourceAsStream(filename);\n      // 5. jar加载\n      if (Objects.isNull(in) &amp;&amp; filename.contains(\"jar!/\")) &#123;\n        val url = new URL(filename);\n        val protocol = url.getProtocol();\n        if (\"jar\".equals(protocol)) &#123;\n          val jar = (JarURLConnection) url.openConnection();\n          in = jar.getInputStream();\n        &#125;\n      &#125;\n      if (Objects.isNull(in)) throw new IllegalStateException(filename);\n      return in;\n    &#125;, filename);\n  &#125;\n&#125;\n\n加载基类,子类继承后实现多种不同的加载方式,比如: yaml 、 xml 、properties 、 json .ILoader.java\npackage org.btr.ygo.core.config;\n\nimport org.btr.ygo.core.kit.Trunk;\n\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface ILoader &#123;\n  // 这里根据后缀名调用对应的loader.\n  Map&lt;String, ILoader> MAP = Map.of(\".yaml\", Trunk.singleton(YamlLoader.class));\n  String load(String filename);\n&#125;\n\n这里我只实现yaml读取,其他省略.\ncore模块build.gradle追加\ndependencies &#123;\n  &#x2F;&#x2F; 读yaml\n  compile &quot;com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:$jacksonVersion&quot;\n&#125;\nYamlLoader.java\npackage org.btr.ygo.core.config;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\nimport org.btr.ygo.core.kit.Fn;\nimport org.btr.ygo.core.kit.IO;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic final class YamlLoader implements ILoader &#123;\n  private static final ObjectMapper YAML = new YAMLMapper();\n  @Override\n  public String load(String filename) &#123;\n    return Fn.ensureRun(() -> YAML.readTree(IO.ensureRead(filename)).toString(), filename);\n  &#125;\n&#125;\n\n\nConfigs.java\npackage org.btr.ygo.core.kit;\n\nimport io.netty.util.internal.StringUtil;\nimport io.vertx.core.json.JsonObject;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.config.ILoader;\nimport org.btr.ygo.core.constant.Console;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class Configs &#123;\n  private static final Map&lt;String, JsonObject> CONFIG = new HashMap&lt;>();\n  // 框架配置文件名,我这里写死了yaml\n  private static final String CONFIG_FILE = \"application.yaml\";\n  // 框架默认配置\n  private static final String DEFAULT = \"ygo/\";\n  // 默认采用的loader,这里我写死了yaml,可自行扩展成动态.\n  private static final ILoader LOADER = ILoader.MAP.get(\".yaml\");\n  // 生成读取文件名\n  // 1. application.yaml\n  // 2. application-key.yaml\n  public static String generateFilename(String key) &#123;\n    return Fn.ensureRun(Objects.isNull(key),\n      () -> CONFIG_FILE,\n      () -> \"application-\" + key + \".yaml\");\n  &#125;\n  public static JsonObject read(String filename) &#123;\n    val name = generateFilename(filename);\n    val value = CONFIG.get(name);\n    // 缓存有则不再走io流读取\n    if (Objects.nonNull(value)) return value;\n    val merged = new JsonObject();\n    // 1.默认配置\n    val defaultPath = DEFAULT + name;\n    val silent = loader(defaultPath);\n    log.info(Console.CONFIG_READ, \"Default\", defaultPath);\n    merged.mergeIn(silent, true);\n    // 2.用户自定义配置\n    log.info(Console.CONFIG_READ, \"User\", name);\n    val custom = loader(name);\n    // 两者配置都存在的场合需要合并\n    if (!custom.isEmpty()) &#123;\n      log.info(Console.MERGE);\n      merged.mergeIn(custom, true);\n    &#125;\n    CONFIG.put(name, merged);\n    return merged;\n  &#125;\n  // 所有loader加载完后统一转换成Vert.x的JsonObject格式数据.\n  private static JsonObject loader(String filename) &#123;\n    val text = LOADER.load(filename);\n    return Fn\n      .ensureRun(StringUtil.isNullOrEmpty(text), JsonObject::new, () -> new JsonObject(text));\n  &#125;\n&#125;\n\n\n框架配置读取器本体整个框架的配置YgoConfig.java\npackage org.btr.ygo.core.config;\n\nimport io.vertx.core.json.JsonObject;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Configs;\n\n/**\n * 框架整体配置\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic final class YgoConfig implements IConfig&lt;JsonObject> &#123;\n  @Override\n  public JsonObject read() &#123;\n    // 读取application.yaml\n    val json = Configs.read(null);\n    return json.getJsonObject(Const.YGO);\n  &#125;\n&#125;\n\n测试在 /test/main/resources 、 /test/main/resources/ygo/ 目录下分别添加 application.yaml 文件.application.yaml\nygo:\n  name: test\n  profile: default\n\n配置读取测试类IConfigTest.java\npackage org.btr.ygo.core.config;\n\nimport lombok.val;\nimport org.btr.ygo.core.kit.Trunk;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic class IConfigTest &#123;\n  @Test\n  public void testYgo() &#123;\n    val config = Trunk.&lt;YgoConfig>singleton(YgoConfig.class);\n    val json = config.read();\n    val data = json.getString(\"name\");\n    Assert.assertEquals(data, \"test\");\n  &#125;\n&#125;\n\n测试结果\n\nVert.x配置读取器本体VertxConfig.java\npackage org.btr.ygo.core.config;\n\nimport io.vertx.core.VertxOptions;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Const;\nimport org.btr.ygo.core.kit.Trunk;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic class VertxConfig implements IConfig&lt;VertxOptions> &#123;\n  @Override\n  public VertxOptions read() &#123;\n    // 先读取框架配置\n    val ygo = Trunk.&lt;YgoConfig>singleton(YgoConfig.class);\n    val config = ygo.read();\n    // 从框架配置中读取Vertx部分\n    val options =  new VertxOptions(config.getJsonObject(Const.VERTX).getJsonObject(Const.OPTIONS));\n    // 这里是我个人习惯,将线程数设置为CPU核心*2\n    // 可以参考这个 https://www.cnblogs.com/dennyzhangdd/p/6909771.html\n    // 工作线程默认为20,如果没变动则将其改为CPU核数*2;\n    if (20 == options.getWorkerPoolSize()) options.setWorkerPoolSize(VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE);\n    return options;\n  &#125;\n&#125;\n\n测试test 文件夹下的 application.yaml 追加内容\nygo:\n  name: test\n  profile: default\n  vertx:\n    name: vertx-ygo\n    options:\n      haEnabled: false\n      preferNativeTransport: true\n\nIConfigTest.java追加测试\npublic class IConfigTest &#123;\n  ...\n  @Test\n  public void testVertx() &#123;\n    val config = Trunk.&lt;VertxConfig>singleton(VertxConfig.class);\n    val options = config.read();\n    Assert.assertTrue(options.getPreferNativeTransport());\n  &#125;\n&#125;\n\n测试结果\n\n总结这一章我们实现了框架配置的yaml读取,并且也留下了修改的入口,日后扩展其他方式也无须修改源代码,子类自行实现 ILoader.java 即可.\n框架的其他参数读取同理,扩展 IConfig.java 即可.\n","slug":"从零开始撸框架(4)-配置读取器","date":"2021-05-01T22:43:37.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"bf9123d57d7a0fda9f11ed154298fba1","title":"从零开始撸框架(3)-类扫描器","content":"上一章我们已经把每个包中的类都统一加载到一个Set中了,以后凡是需要用到类的场景我们都可以从Set集合中取出,但是光这样还不够好.往后所有操作都依赖于这一个集合,这也意味着我们对集合元素有改动都会影响到所有组件使用.所以这一章我们来进一步细化,根据不同的需求把这个大Set集合拆分成小的集合.\n扫描基类这里我们定义一个扫描接口,接收类集合得出我们想要的结果,方便子类根据不同需求进行扩展.\nIScanner.java\npackage org.btr.ygo.core.scan;\n\nimport java.util.Set;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic interface IScanner&lt;T> &#123;\n  T scan(Set&lt;Class&lt;?>> classes);\n&#125;\n\n下面根据需求实现不同的子类,这里采用的是Reactor架构模型.\n\n事件循环线程(Eventloop)扫描器首先我们把所有事件循环的类从Set集合中独立出来,这块是框架调度分发的核心,完全有独立出来的意义.\n辅助类这里定义几种类型,分别对应http、tcp、sock服务.EventloopType.java\npackage org.btr.ygo.constant;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic enum EventloopType &#123;\n  HTTP, TCP, SOCK;\n  private static final List&lt;String> HTTP_TYPE =\n    Arrays.asList(HTTP.name().toLowerCase(), SOCK.name().toLowerCase());\n  public static boolean isHttp(String type) &#123;\n    return HTTP_TYPE.contains(type);\n  &#125;\n  public static boolean isNet(String type) &#123;\n    return TCP.name().equalsIgnoreCase(type);\n  &#125;\n&#125;\n注解式开发,用注解把类标识出来.Eventloop.java\npackage org.btr.ygo.annotations;\n\nimport org.btr.ygo.constant.EventloopType;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)\npublic @interface Eventloop &#123;\n  boolean ha() default false;\n  int instances() default 1;\n  EventloopType type() default EventloopType.HTTP;\n&#125;\n\n本体具体的事件循环扫描实现,通过扫描包含@Eventloop注解的类.\nEventloopScanner.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Eventloop;\nimport org.btr.ygo.core.constant.Console;\n\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class EventloopScanner implements IScanner&lt;Set&lt;Class&lt;?>>> &#123;\n  @Override\n  public Set&lt;Class&lt;?>> scan(Set&lt;Class&lt;?>> classes) &#123;\n    val ret =\n      classes.stream().filter(d -> d.isAnnotationPresent(Eventloop.class)).collect(Collectors.toSet());\n    log.info(Console.SCANNED, \"Eventloop\", ret.size());\n    return ret;\n  &#125;\n&#125;\n测试IScannerTest.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Eventloop;\nimport org.btr.ygo.core.kit.Packages;\nimport org.btr.ygo.core.kit.Trunk;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic class IScannerTest &#123;\n  @Eventloop\n  public static class TestEventloop &#123;\n  &#125;\n  @Test\n  public void testEventloop() &#123;\n    val classes = Packages.scan();\n    val scanner = Trunk.&lt;EventloopScanner>singleton(EventloopScanner.class);\n    val ret = scanner.scan(classes);\n    Assert.assertThat(ret, CoreMatchers.hasItem(TestEventloop.class));\n  &#125;\n&#125;\n测试结果\n\n工作线程(Worker)扫描器工作类负责框架各种任务的执行,具体实现同Eventloop.\n辅助类Worker.java\npackage org.btr.ygo.core.annotations;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Inherited\n@Documented\n@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Worker &#123;\n  boolean ha() default false;\n  int instances() default 1;\n&#125;\n\n本体WorkerScanner.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Worker;\nimport org.btr.ygo.core.constant.Console;\n\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class WorkerScanner implements IScanner&lt;Set&lt;Class&lt;?>>> &#123;\n  @Override\n  public Set&lt;Class&lt;?>> scan(Set&lt;Class&lt;?>> classes) &#123;\n    val ret =\n      classes.stream().filter(d -> d.isAnnotationPresent(Worker.class)).collect(Collectors.toSet());\n    log.info(Console.SCANNED, \"Worker\", ret.size());\n    return ret;\n  &#125;\n&#125;\n测试在IScannerTest.java中追加一例测试.\npublic class IScannerTest &#123;\n  ...\n  @Worker\n  public static class TestWorker &#123;\n  &#125;\n  @Test\n  public void testWorker() &#123;\n    val classes = Packages.scan();\n    val scanner = Trunk.&lt;WorkerScanner>singleton(WorkerScanner.class);\n    val ret = scanner.scan(classes);\n    Assert.assertThat(ret, CoreMatchers.hasItem(TestWorker.class));\n  &#125;\n&#125;\n测试结果\n\nVert.x消息扫描器在Vert.x官网示例中,我们可以看到它Eventloop与Worker交互是通过vertx.eventBus()来实现的.因此我们把交互消息也定义成一个类,把它也从类集合中独立出来.\n辅助类Receipt.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.AccessLevel;\nimport lombok.Data;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.FieldDefaults;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Data\n@Accessors(chain = true)\n@FieldDefaults(level = AccessLevel.PRIVATE)\npublic class Receipt &#123;\n  // 承载消息的类.\n  Object proxy;\n  // 发布在Vert.x上的消息地址.\n  String addr;\n  // 具体执行的方法.\n  Method method;\n&#125;\n分别定义EventBus和Addr两个注解,用来标识类是否要处于Vert.x的消息队列中和类在队列上的地址.EventBus.java\npackage org.btr.ygo.core.annotations;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)\npublic @interface EventBus &#123;\n&#125;\nAddr.java\npackage org.btr.ygo.core.annotations;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Inherited\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123;ElementType.METHOD,ElementType.ANNOTATION_TYPE&#125;)\npublic @interface Addr &#123;\n  String value();\n&#125;\n\n我们在之前的Trunk.java工厂类中添加新的方法,分别实现获取实现类和代理类的功能.Trunk.java\npublic final class Trunk &#123;\n  ...\n  public static Class&lt;?> getImpl(Class&lt;?> cls) &#123;\n    return Fn.ensureRun(() -> &#123;\n      // 搜索全部包下的类得到所有cls实现的类,必须是单实现.\n      val classes = Packages.scan().stream()\n        // 过滤掉自身以及子类\n        .filter(d -> cls.isAssignableFrom(d) &amp;&amp; d != cls)\n        .collect(Collectors.toList());\n      return 1 == classes.size() ? classes.get(0) : null;\n    &#125;, cls);\n  &#125;\n  public static Object getProxy(Class&lt;?> cls) &#123;\n    return Fn.ensureRun(!cls.isInterface(),\n      // 非接口直接单例对象\n      () -> Trunk.singleton(cls),\n      () -> &#123;\n        // 接口获取其实现类\n        val implCls = Trunk.getImpl(cls);\n        // 实现类不为空获取其单例对象\n        return Fn.ensureRun(() -> Trunk.singleton(implCls), implCls);\n      &#125;);\n  &#125;\n&#125;\n\n本体ReceiptScanner.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.annotations.Addr;\nimport org.btr.ygo.core.annotations.EventBus;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.kit.Methods;\nimport org.btr.ygo.core.kit.Trunk;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class ReceiptScanner implements IScanner&lt;Set&lt;Receipt>> &#123;\n  @Override\n  public Set&lt;Receipt> scan(Set&lt;Class&lt;?>> classes) &#123;\n    // 所有@EventBus注解的类\n    val eventBuses = classes.stream().filter(d -> d.isAnnotationPresent(EventBus.class))\n      .collect(Collectors.toSet());\n    log.info(Console.SCANNED, \"EventBus\", eventBuses.size());\n    val receipts = eventBuses.stream()\n      // 根据类下所有的方法,将其转成为Receipt对象.\n      .flatMap(d -> Arrays.stream(d.getDeclaredMethods()).filter(Methods::validateMethod))\n      .map(this::scan).collect(Collectors.toSet());\n    log.info(Console.SCANNED, \"Address\", receipts.size());\n    return receipts;\n  &#125;\n  private Receipt scan(Method method) &#123;\n    val cls = method.getDeclaringClass();\n    val proxy = Trunk.getProxy(cls);\n    val addr = method.getAnnotation(Addr.class).value();\n    val data = new Receipt().setAddr(addr).setMethod(method)\n      .setProxy(proxy);\n    log.info(\"Address: &#123;&#125;\", addr);\n    return data;\n  &#125;\n&#125;\n测试继续在IScannerTest.java追加测试\npublic class IScannerTest &#123;\n  ...\n  @EventBus\n  public static class TestEventBus &#123;\n    @Addr(\"test\")\n    public void test() &#123;\n    &#125;\n  &#125;\n  @Test\n  public void testReceipt() &#123;\n    val classes = Packages.scan();\n    val scanner = Trunk.&lt;ReceiptScanner>singleton(ReceiptScanner.class);\n    val data = new Receipt().setAddr(\"test\");\n    val xs = scanner.scan(classes);\n    val ret = xs.stream().filter(d -> data.getAddr().equals(d.getAddr())).findAny();\n    Assert.assertTrue(ret.isPresent());\n  &#125;\n&#125;\n测试结果\n\n依赖注入(Dependency Injection)扫描器用过spring的都知道 @Resource 、 @Autowire 注入,其中前者是jsr250的,后者是spring封装的.\n这里我们也可以封装一套类似于Spring的,也可以基于现有的注解开发,在这我选择基于jsr330注解开发.\n在core模块build.gradle中追加\ndependencies &#123;\n  ...\n  &#x2F;&#x2F; jsr330\n  compile &quot;javax.inject:javax.inject:1&quot;\n  ...\n&#125;\n\n辅助类在Trunk.java追加一个新的方法\npublic final class Trunk &#123;\n  ...\n  // 递归查询是否有实现类\n  public static boolean hasMatchImpl(Class&lt;?> cls, Class&lt;?> interfaceCls) &#123;\n    var b = Arrays.asList(cls.getInterfaces()).contains(interfaceCls);\n    if (!b &amp;&amp; Objects.nonNull(cls.getSuperclass()))\n      b = hasMatchImpl(cls.getSuperclass(), interfaceCls);\n    return b;\n  &#125;\n&#125;\n\n这里和Package扫描一样,类比较多,我们一个类创建一个线程来加快注入的扫描.DiThread.java\npackage org.btr.ygo.core.scan;\n\nimport io.netty.util.internal.StringUtil;\nimport lombok.AccessLevel;\nimport lombok.experimental.FieldDefaults;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Console;\nimport org.btr.ygo.core.kit.Trunk;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@FieldDefaults(level = AccessLevel.PUBLIC, makeFinal = true)\npublic final class DiThread extends Thread &#123;\n  // 当前类\n  Class&lt;?> cls;\n  // 所有类,需要在这里面找到当前类所有字段类型实现来注入.\n  Set&lt;Class&lt;?>> classes;\n  // 当前类所有字段的对应类型\n  Map&lt;String, Class&lt;?>> FIELD_INJECTS = new HashMap&lt;>();\n  public DiThread(Class&lt;?> cls, Set&lt;Class&lt;?>> classes) &#123;\n    setName(\"ygo-di-scanner-\" + getId());\n    this.cls = cls;\n    this.classes = classes;\n  &#125;\n  @Override\n  public void run() &#123;\n    // 类转换成类字段数组\n    val fields = Arrays.stream(cls.getDeclaredFields())\n      // 过滤掉没有@Inject注解的字段\n      .filter(field -> field.isAnnotationPresent(Inject.class))\n      // 转成 key -> 类字段名 value -> 字段类型的map格式 \n      .collect((Supplier&lt;HashMap&lt;String, Class&lt;?>>>) HashMap::new,\n        (map, field) -> map.put(field.getName(), standard(field)), HashMap::putAll);\n    FIELD_INJECTS.putAll(fields);\n  &#125;\n  // 标准注入\n  private Class&lt;?> standard(Field field) &#123;\n    val type = field.getType();\n    if (!type.isInterface()) return type;\n    val name = field.getName();\n    // 字段的实现列表\n    val impls =\n      classes.stream().filter(cls -> Trunk.hasMatchImpl(cls, type)).collect(Collectors.toList());\n    // 空实现\n    if (impls.isEmpty()) &#123;\n      val typeName = field.getDeclaringClass().getName();\n      log.error(Console.JSR330, typeName, name, type.getName());\n      throw new IllegalArgumentException();\n    &#125;\n    else &#123;\n      val size = impls.size();\n      // 多实现\n      if (1 != size) return qualifier(field, impls);\n        // 只有一个实现\n      else &#123;\n        val implCls = impls.get(0);\n        log.info(Console.DI, cls, name, implCls.getName(), Inject.class);\n        return implCls;\n      &#125;\n    &#125;\n  &#125;\n  // 多实现,通过value指定实例.\n  private Class&lt;?> qualifier(Field field, List&lt;Class&lt;?>> implClasses) &#123;\n    val names = implClasses.stream().map(Class::getName).collect(Collectors.toList());\n    log.info(Console.SCANNED, \"Instance\", String.join(\",\", names));\n    val qualifier = field.getAnnotation(Named.class).value();\n    val cls = implClasses.stream()\n      .filter(item -> &#123;\n        val named = item.getAnnotation(Named.class).value();\n        return qualifier.equals(named) &amp;&amp; !StringUtil.isNullOrEmpty(named);\n      &#125;).findAny();\n    return cls.get();\n  &#125;\n&#125;\n\n本体DiScanner.java\npackage org.btr.ygo.core.scan;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Console;\n\nimport javax.inject.Inject;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class DiScanner implements IScanner&lt;Map&lt;Class&lt;?>, Map&lt;String, Class&lt;?>>>> &#123;\n  @Override\n  public Map&lt;Class&lt;?>, Map&lt;String, Class&lt;?>>> scan(Set&lt;Class&lt;?>> classes) &#123;\n    // 所有包含@Inject注解字段的类\n    val xs = classes.stream().filter(cls -> Arrays.stream(cls.getDeclaredFields())\n      .anyMatch(field -> field.isAnnotationPresent(Inject.class)))\n      .collect(Collectors.toSet());\n    // 一个类一个线程\n    val threads = xs.stream().map(cls -> new DiThread(cls, classes))\n      .collect(Collectors.toSet());\n    // 线程启动\n    threads.forEach(Thread::start);\n    // 最终返回数据结构 key -> 类类型, value -> (key -> 字段名, value -> 字段类型).\n    val ret = new HashMap&lt;Class&lt;?>, Map&lt;String, Class&lt;?>>>();\n    try &#123;\n      // 主线程等待子线程全部扫描完毕\n      for (DiThread thread : threads) thread.join();\n      for (DiThread thread : threads) &#123;\n        val key = thread.cls;\n        val value = thread.FIELD_INJECTS;\n        ret.put(key, value);\n        log.info(Console.INJECT, key.getName(), value.size());\n      &#125;\n    &#125; catch (Exception ex) &#123;\n      ex.printStackTrace();\n    &#125;\n    return ret;\n  &#125;\n&#125;\n\n测试IScannerTest.java追加\npublic class IScannerTest &#123;\n  ...\n  public interface TestQualifier &#123;&#125;\n  @Named(\"testQualifierA\")\n  public static class TestQualifierA implements TestQualifier &#123;&#125;\n  @Named(\"testQualifierB\")\n  public static class TestQualifierB implements TestQualifier &#123;&#125;\n  public static class TestDi &#123;\n    @Inject\n    private TestEventBus testEventBus;\n    @Inject\n    @Named(\"testQualifierB\")\n    private TestQualifier testQualifier;\n  &#125;\n  @Test\n  public void testDi() &#123;\n    val classes = Packages.scan();\n    val scanner = Trunk.&lt;DiScanner>singleton(DiScanner.class);\n    val ret = scanner.scan(classes);\n    val data = ret.get(TestDi.class);\n    val type1 = data.get(\"testEventBus\");\n    Assert.assertEquals(type1, TestEventBus.class);\n    val type2 = data.get(\"testQualifier\");\n    Assert.assertNotEquals(type2, TestQualifierA.class);\n    Assert.assertEquals(type2, TestQualifierB.class);\n  &#125;\n&#125;\n测试结果\n\n总结这一章我们基于一个扫描基类实现了各个核心组件的解耦扫描,以后有新的组件只需要自行扩展实现IScanner.java即可.\n在往后几章我们肯定还会基于这个基类继续扩展功能实现.\n","slug":"从零开始撸框架(3)-类扫描器","date":"2021-05-01T16:01:49.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"1f961444d2b8322d4f975faeb98fbea1","title":"从零开始撸框架(2)-项目龙骨","content":"项目结构上文说到框架包含Ioc、Di、Orm、Cache等功能,其中只有前两者为核心功能.那么结构上可以采用分包结构开发,即分为核心、组件等功能包,如下.\n\norg.btr.ygo.core 核心包,包含了框架ioc、di功能,为其他组件提供支持.\norg.btr.ygo.tp tp意为(third-party),可以将数据库、缓存等需要引入第三方jar的功能放到这.\norg.btr.ygo.web web功能\n\n接下来我们先完成core核心包的功能开发.\n\n工厂说到核心Ioc、Di自然离不开工厂模式.我们先准备写工厂会用到的jar\nbuild.gradle\ndependencies &#123;\n  &#x2F;&#x2F; 高性能反射\n  compile &quot;com.esotericsoftware:reflectasm:1.11.9&quot;\n  &#x2F;&#x2F; vertx核心jar\n  compile &quot;io.vertx:vertx-core:$vertxVersion&quot;\n&#125;\n\n辅助类类工厂会经常用到反射,我们需要写几个类来辅助工厂实现.\n函数类,这里会存放以后会用到的各种函数式方法.EnsureSuppliver.java\npackage org.btr.ygo.core.funtions;\n\n/**\n * java8的异常版本\n * @see java.util.function.Supplier\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@FunctionalInterface\npublic interface EnsureSuppliver&lt;T> &#123;\n  T get() throws Exception;\n&#125;\nEnsureExec.java\npackage org.btr.ygo.core.funtions;\n\n/**\n * java8的异常版本\n * @see java.util.function.Consumer\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@FunctionalInterface\npublic interface EnsureExec &#123;\n  void exec() throws Exception;\n&#125;\nFn.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\nimport org.btr.ygo.core.funtions.EnsureExec;\nimport org.btr.ygo.core.funtions.EnsureSuppliver;\n\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Supplier;\n\n/**\n * 函数类,封装了条件分支以及非空判断.\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class Fn &#123;\n  // 连接池函数,优先使用key在池中找可用value,找不到才会通过Supplier去创建一个value.\n  public static &lt;K, V> V pool(Map&lt;K, V> map, K key, Supplier&lt;V> fn) &#123;\n    V value = map.get(key);\n    if (Objects.isNull(value)) &#123;\n      value = fn.get();\n      map.put(key, value);\n    &#125;\n    return value;\n  &#125;\n  public static &lt;T> T ensureRun(EnsureSuppliver&lt;T> fn, Object... args) &#123;\n    return ensureRun(null, fn, args);\n  &#125;\n  public static &lt;T> T ensureRun(T defaultValue, EnsureSuppliver&lt;T> fn, Object... args) &#123;\n    T ret = null;\n    try &#123;\n      if (Arrays.stream(args).allMatch(Objects::nonNull)) ret = fn.get();\n    &#125; catch (Exception e) &#123;\n      e.printStackTrace();\n    &#125; finally &#123;\n      if (Objects.isNull(ret)) ret = defaultValue;\n    &#125;\n    return ret;\n  &#125;\n  public static &lt;T> T ensureRun(boolean condition, EnsureSuppliver&lt;T> fn1, EnsureSuppliver&lt;T> fn2) &#123;\n    T ret = null;\n    try &#123;\n      if (condition) &#123;\n        if (Objects.nonNull(fn1)) ret = fn1.get();\n      &#125;\n      else &#123;\n        if (Objects.nonNull(fn2)) ret = fn2.get();\n      &#125;\n    &#125; catch (Exception e) &#123;\n      e.printStackTrace();\n    &#125;\n    return ret;\n  &#125;\n  public static void ensureExec(EnsureExec fun, Object... args) &#123;\n    try &#123;\n      if (Arrays.stream(args).allMatch(Objects::nonNull)) fun.exec();\n    &#125; catch (Exception ex) &#123;\n      ex.printStackTrace();\n    &#125;\n  &#125;\n&#125;\n\n反射类,有关反射的方法都放在这.Reflect.java\npackage org.btr.ygo.core.kit;\n\nimport com.esotericsoftware.reflectasm.ConstructorAccess;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\n\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@SuppressWarnings(\"all\")\npublic final class Reflect &#123;\n  // reflectasm开销主要在于对象的获取,我们把它存起来.\n  private static final Map&lt;Class&lt;?>, ConstructorAccess> CONSTRUCTORS = new HashMap&lt;>();\n  public static &lt;T> T constructor(Class&lt;?> cls, Object... args) &#123;\n    T ret = null;\n    try &#123;\n      val constructors = cls.getDeclaredConstructors();\n      // 拿到类的所有构造函数,我们根据参数来判断选用何种方式创建对象.\n      // 优先使用无参,这样能调用到reflectasm.\n      // 无参不满足就只能走Java原生了.\n      for (Constructor&lt;?> constructor : constructors) &#123;\n        val size = args.length;\n        if (0 == size) ret = noArgConstructor(cls);\n        else if (size != constructor.getParameterTypes().length) continue;\n        ret = (T) constructor.newInstance(args);\n      &#125;\n      return ret;\n    &#125; catch (Exception e) &#123;\n      e.printStackTrace();\n      return ret;\n    &#125;\n  &#125;\n  // 这里用到了reflectasm高性能反射,缺点就是仅支持无参.\n  public static &lt;T> T noArgConstructor(Class&lt;?> cls) &#123;\n    val access = Fn.pool(CONSTRUCTORS, cls, () -> ConstructorAccess.get(cls));\n    return (T) access.newInstance();\n  &#125;\n&#125;\n\n本体Trunk.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@SuppressWarnings(\"unchecked\")\npublic final class Trunk &#123;\n  // 单例存储所有类对象\n  private static final Map&lt;String, Object> SINGLETON = new HashMap&lt;>();\n  // 所有扫描的类\n  public static final Set&lt;Class&lt;?>> CLASSES = new HashSet&lt;>();\n  // 单例,优先读map对象,无则懒加载获取实例并存入map.\n  public static &lt;T> T singleton(Class&lt;?> cls, Object... args) &#123;\n    return (T) Fn.pool(SINGLETON, cls.getName(), () -> instance(cls, args));\n  &#125;\n  // 实例,每调用一次产生一例.\n  public static &lt;T> T instance(Class&lt;?> cls, Object... args) &#123;\n    return Fn\n      .ensureRun(0 == args.length, () -> Reflect.noArgConstructor(cls), () -> Reflect.constructor(cls, args));\n  &#125;\n&#125;\n\n测试TrunkTest.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.TestApi;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic class TrunkTest &#123;\n  @Test\n  public void testInstance() &#123;\n    val i1 = Trunk.instance(TestApi.class);\n    val i2 = Trunk.instance(TestApi.class);\n    log.info(\"i1: &#123;&#125;, i2: &#123;&#125;\", i1, i2);\n    Assert.assertNotEquals(i1, i2);\n  &#125;\n  @Test\n  public void testSingleton() &#123;\n    val i1 = Trunk.singleton(TestApi.class);\n    val i2 = Trunk.singleton(TestApi.class);\n    log.info(\"i1: &#123;&#125;, i2: &#123;&#125;\", i1, i2);\n    Assert.assertEquals(i1, i2);\n  &#125;\n&#125;\n\n测试结果\n\n类扫描加载Bean管理工厂有了接下来我们来实现类的扫描加载.\n辅助类由于包比较多,我们可以一包一线程的方式进行扫描,加速类的扫描.PackageThread.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.val;\n\nimport java.io.File;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n * 包扫描线程,一包一线程.\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic final class PackageThread extends Thread &#123;\n  public final String name;\n  Set&lt;Class&lt;?>> classes = new HashSet&lt;>();\n  public PackageThread(String name) &#123;\n    setName(\"ygo-package-scanner-\" + getId());\n    this.name = name;\n  &#125;\n  @Override\n  public void run() &#123;\n    classes.addAll(getClasses(null, name));\n  &#125;\n  public Set&lt;Class&lt;?>> getClasses(Predicate&lt;Class&lt;?>> filter, String name) &#123;\n    val classes = new LinkedHashSet&lt;Class&lt;?>>();\n    boolean recursive = true;\n    // a.b.c -> a/b/c\n    val pkgDir = name.replace('.', '/');\n    Fn.ensureExec(() -> &#123;\n      val dirs = Thread.currentThread().getContextClassLoader().getResources(pkgDir);\n      while (dirs.hasMoreElements()) &#123;\n        val url = dirs.nextElement();\n        val protocol = url.getProtocol();\n        if (\"file\".equals(protocol)) &#123;\n          val path = URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8);\n          findAndAdd(pkgDir, path, classes);\n        &#125;\n        else if (\"jar\".equals(protocol))\n          classes.addAll(getJarClasses(pkgDir, name, url, recursive));\n      &#125;\n    &#125;);\n    return null == filter ? classes : classes.stream().filter(filter).collect(Collectors.toSet());\n  &#125;\n  private Set&lt;Class&lt;?>> getJarClasses(String pkgDir, String name, URL url,\n    boolean recursive) &#123;\n    val classes = new LinkedHashSet&lt;Class&lt;?>>();\n    Fn.ensureRun(() -> &#123;\n      // 去掉第一个.\n      var pkgPath = (name.startsWith(\".\")) ? name.substring(1) : name;\n      val jar = ((JarURLConnection) url.openConnection()).getJarFile();\n      val entries = jar.entries();\n      while (entries.hasMoreElements()) &#123;\n        val entry = entries.nextElement();\n        var entryName = entry.getName();\n        // 去掉第一个/\n        if (entryName.charAt(0) == '/') entryName = entryName.substring(1);\n        if (entryName.startsWith(pkgDir)) &#123;\n          val idx = entryName.lastIndexOf('/');\n          // entryName存在/说明是package\n          // java/lang -> java.lang\n          if (idx != -1) pkgPath = entryName.substring(0, idx).replace('/', '.');\n          if ((idx != -1) || recursive) &#123;\n            // class文件\n            if (entryName.endsWith(\".class\") &amp;&amp; !entry.isDirectory()) &#123;\n              // 提取class文件名\n              val clsName =\n                entryName\n                  .substring(pkgPath.length() + 1, entryName.lastIndexOf(\".class\"));\n              classes.add(Thread.currentThread().getContextClassLoader()\n                .loadClass(pkgPath + '.' + clsName));\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n      return null;\n    &#125;, pkgDir, name, url);\n    return classes;\n  &#125;\n  private void findAndAdd(String pkgDir, String path, Set&lt;Class&lt;?>> classes) &#123;\n    Fn.ensureExec(() -> &#123;\n      val file = new File(path);\n      if (!file.exists() || !file.isDirectory()) return;\n      val classFiles =\n        file.listFiles(pathname -> (file.isDirectory()) || file.getName().endsWith(\".class\"));\n      if (Objects.isNull(classFiles)) return;\n      // 去掉第一个.\n      val pkgPath = (pkgDir.startsWith(\".\")) ? pkgDir.substring(1) : pkgDir;\n      // 是否存在另一个文件夹\n      val processedName = pkgPath.replace('/', '.');\n      for (File cls : classFiles) &#123;\n        // 目录直接跳过\n        if (cls.isDirectory())\n          findAndAdd(processedName + '.' + cls.getName(), cls.getAbsolutePath(),\n            classes);\n        else &#123;\n          val clsName = cls.getName();\n          val name = clsName.substring(0, clsName.lastIndexOf(\".class\"));\n          classes.add(Thread.currentThread().getContextClassLoader()\n            .loadClass(processedName + '.' + name));\n        &#125;\n      &#125;\n    &#125;, pkgDir, path);\n  &#125;\n&#125;\n\n本体Packages.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.constant.Console;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class Packages &#123;\n  // 忽略不扫描的包\n  private static final Set&lt;String> IGNORE_PACKAGES = Set.of(\n    \"ch.qos.logback\",\n    \"io.vertx.core\",\n    \"io.netty\",\n    \"com.fasterxml.jackson\",\n    \"com.esotericsoftware\",\n    \"java\",\n    \"javax\",\n    \"jdk\",\n    \"sun\",\n    \"groovy\",\n    \"org.graalvm\",\n    \"org.apache\",\n    \"org.jboss\",\n    \"com.sun\",\n    \"org.slf4j\",\n    \"org.yaml\",\n    \"org.junit\",\n    \"org.apache.logging.log4j\"\n  );\n  public static Set&lt;Class&lt;?>> scan() &#123;\n    if (Trunk.CLASSES.isEmpty()) &#123;\n      val classes = scan(getPackages().toArray(new String[]&#123;&#125;));\n      Trunk.CLASSES.addAll(classes);\n      log.info(Console.SCANNED, \"Class\", classes.size());\n    &#125;\n    return Trunk.CLASSES;\n  &#125;\n  private static Set&lt;String> getPackages() &#123;\n    val pkgs = Arrays.stream(Package.getPackages())\n      .map(Package::getName)\n      .filter(name -> IGNORE_PACKAGES.stream().noneMatch(name::startsWith))\n      .collect(Collectors.toSet());\n    log.info(Console.SCANNED, \"Package\", pkgs.size());\n    return pkgs;\n  &#125;\n  // 多线程扫描\n  private static HashSet&lt;Class&lt;?>> scan(String[] dirs) &#123;\n    val threads = Arrays.stream(dirs).map(PackageThread::new).collect(Collectors.toSet());\n    threads.forEach(Thread::start);\n    val ret = new HashSet&lt;Class&lt;?>>();\n    try &#123;\n      // 主线程等待子线程全部扫描完毕\n      for (PackageThread thread : threads) thread.join();\n      // 将所有线程值合并\n      for (PackageThread thread : threads) ret.addAll(thread.classes);\n    &#125; catch (Exception ex) &#123;\n      ex.printStackTrace();\n    &#125;\n    return ret;\n  &#125;\n&#125;\n\n测试PackageTest.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.val;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\npublic class PackagesTest &#123;\n  @Test\n  public void test() &#123;\n    val classes = Packages.scan();\n    Assert.assertThat(classes, CoreMatchers.hasItem(Packages.class));\n  &#125;\n&#125;\n\n测试结果\n\n总结这一章我们完成了核心模块的龙骨搭建,让它拥有了两个最原始的功能,即工厂和类集合,有了这俩我们才能开发其他的组件.\n","slug":"从零开始撸框架(2)-项目龙骨","date":"2021-04-29T02:03:09.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"1da24bfae57d43586cc931d1d18b42d9","title":"奇淫巧技(2)-Jvm篇","content":"函数内联在讲函数内联之前还得讲一个Jvm经常遇到的异常StackOverFlowException,该异常一般翻译成堆栈溢出异常,其实正确或者说更严谨的翻译应该是栈溢出,栈溢出大部分发生在函数的循环或递归调用之中,极少数在对象循环创建中.\n函数调用过程\nJvm栈内存会存储所有热度函数以及它们本地变量和函数.\n新函数调用,新的栈帧加到了栈顶端,分配的本地变量和参数会存储在这.\n跳转到目标函数执行代码.\n函数返回,本地变量和参数都会销毁,栈顶被移除.\n返回原先地址继续执行.\n\n观察调用过程可以看到每次函数调用消耗都比较大,如果放在循环之中不停的重复压栈出栈操作就会导致栈溢出.\n如何优化// 1\nfor (int i = 0; i &lt; list.size(); i++)\n// 2\nfor (int i = 0,j = list.size(); i &lt; j; i++)\n\n\n方式1每次循环都会去调用list来获取他最新的size长度,上面我们已经说到了函数调用的开销,故而方式1会随着循环不断增加开销,此时函数的开销是N.\n方式2只在循环初始化的时候进行了一次函数调用获取size长度并用局部变量保存下来,后面循环开始之后再也没有函数调用开销,此时函数开销始终是1.\n\n如何避免或减少开销这时候就该聊到我们上面提到的函数内联了,它可以显著减少栈帧的创建,多个函数使用一个栈帧来避免栈帧过分.在Jvm中无法人为强行函数内联,只能建议.Jvm是通过函数字节大小以及热度来决定是否内联的,因为我们只要日常代码中满足以下条件即可.\n\n函数字节小于35字节时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxInlineSize=N**来调整内联字节数\n当函数字节小于325字节并且函数是热点时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxFreqInlineSize=N**来调整内联字节数\nJvm自动识别函数热度进行内联,我们也可以通过修改Jvm参数**-XX:CompileThreshold=N**来调整函数热度\n这算是函数内联的隐含条件,编码中多多使用private、static、final来定义函数.如果一个函数没有被外部使用,用这些关键字可以建议Jvm进行内联.,Scala可以直接使用@inline注解来建议Jvm内联.\n\n","slug":"奇淫巧技(2)-Jvm篇","date":"2021-04-28T00:04:30.000Z","categories_index":"奇淫巧技","tags_index":"Jvm","author_index":"因雨而生"},{"id":"91972c9f8cfda280c91f3305c833ffbf","title":"奇淫巧技(1)-Java篇","content":"编码习惯多使用值(val)而不是变量(var)\n变量非线程安全,并发存在读写问题.而值因为其不可修改性天然线程安全无读写问题.多线程开发中值也不用锁,性能更优,程序猿也不用关心多线程下的并发读写锁问题,心智要求大大降低.\n单线程性能也更高,如图.// 1\npublic static int sum() &#123;\n  int a = 2;\n  int b = 3;\n  return a + b;\n&#125;\n// 2\npublic static int sum() &#123;\n  val a = 2;\n  val b = 3;\n  return a + ｂ；\n&#125;\n方式１编译后iconst_2\n// 设置a的值\nistore_0\niconst_3\n// 设置b的值\nistore_1\n// 读取a的值\niload_0\n// 读取b的值\niload_1\niadd\nireturn\n方式2编译后// 常量折叠了,没有访问\"局部变量\"\niconst_5\nireturn\n不过有的场景下值与变量并无二异,比如将上图代码的常量值替换成动态计算的函数// 1\npublic static int sum() &#123;\n  int a = fun1();\n  int b = fun2();\n  return a + b;\n&#125;\n// 2\npublic static int sum() &#123;\n  val a = fun1();\n  val b = fun2();\n  return a + b;\n&#125;\n编译后invokestatic fun1:()I\n// 设置a的值\nistore_0\ninvokestatic fun2:()I\n// 设置b的值\nistore_1\n// 读取a的值\niload_0\n// 读取b的值\niload_1\niadd\nireturn\n\nswitch优化\n工具jarLombokLombok是一个简化Java代码的神兵利器,提供了很多非常实用的注解(并且是非运行时),能减少大量重复代码,其具体实现原理及机制在这不做展开,这里只讲应用.\n\n@Data 常用于开发中的Entity、VO、DTO上,会自动为其属性生成Getter、Setter函数,并覆盖实现了原生的ToString、HashCode、Equals函数.\n@Log4j2、Slf4j 为注解类生成一个日志静态量,名为log.\n@AllArgsConstructor 生成一个全参构造,一般配合构造注入使用.\n@Builder 设计模式中的建造者模式\n@Value 构建一个值对象,即类的属性都是不可变量.\n@Cleanup 自动为IO类型关闭资源.\nval Java9var的常量版本.ex: val i = 1等效于final int i = 1;.\n\nVavrVavr为Java提供了更为强大的Fp支持,虽然比不上其他Fp语言的简单明了,但在Java也算是首屈一指的函数式第三方jar了.\n\nOption(单个数据处理) 相比Optional更加完备\nTry(异常处理)\nValidation(数据校验)\nEither(异常处理)\nFuture(异步处理)\nTuple(元祖类型)\nLazy(惰性求值)\n\n每个函数更具体的信息官方文档都有详细介绍Vavr\n","slug":"奇淫巧技(1)-Java篇 ","date":"2021-04-27T23:20:29.000Z","categories_index":"奇淫巧技","tags_index":"Java,面向函数(FP)","author_index":"因雨而生"},{"id":"f1128ae1167b6a3027acc0aa9f078931","title":"从零开始撸框架(1)-写在开始之前","content":"起因码农日常搬砖中都听说过一句话: 不要重复造轮子(一说是不要造重复的轮子).与公司来说这句话自然是绝对正确的,自研或仿造的轮子往往各方面都不如开源现有的轮子来得好,这样对公司来说无疑是最致命的.但是与个人来说,造轮子的过程同时是阅读他人代码提升自己的过程,而且轮子造完自身也会有种莫名的满足感.\n随着开发的深入,项目需求越来越复杂.市面上一些开源轮子(Spring-boot,Vert.x,Akka)无法满足我们功能需求,自此日常开发中也会采用一些二次轮子(即基于开源轮子再封装一层, ex: Jeecg-boot, Di-boot…各种基于Spring-boot或封装或魔改的轮子).这类二次轮子中维护者或个人或公司,个人的全靠满腔热血,bug反馈以及后期升级堪忧.公司的往往包含多版本(民用、商用、企业)等并且收费不低.关于收费这事我个人看法就是不耻,诚然小部分公司都对这些开源轮子进行了大部分改动,但那总归只是少数.绝大部分都是给开源轮子封了一层皮就敢拿出来卖,这也是前阵子为啥Elastic修改开源协议这档子事.\n回到现在,既然市面上二次轮子也不少.我如今趁着三分钟热度也来造一个轮子未尝不可,只是这次我要和市面上常见的那些妖艳贱货不一样,绝对不会采用一些已经烂大街的技术或框架(当然这并不绝对).这次写下这一系列文章一方面给自己留档,一方面给以后那些想造轮子又找不到方法的朋友参考,这个小白兔有人替你们当了.\n定位所谓定位就是这框架目的是什么,起到什么作用,解决什么问题,适用什么场景,面向什么人员.个人认为对于项目刚启动时候的定位不一定就需要画类图写设计文档,毕竟最初只有雏形概念.我们完全可以把核心概念草稿下来就好,日后再补上类图设计文档也不是问题.\n我们这次框架目的就是造一个类似于Spring-boot的轮子,但是又不那么大众化,定位自然就是一个拥有Ioc、Di、Cache、Orm、Rpc的web开发框架.\n技术选型说完了定位来聊聊技术的选型,框架一般来说最重要就那么几个东西,稳定、易用、高性能、可扩展,结合一下几点我们可以筛选出以下几个来.\n\nJava 语言层面毫无疑问它是最满足需求的,比他高性能(c、c++、rust…)的没他简单,比他简单的又没他的性能(js、php…),我个人是偏爱scala的,奈何jvm上和java比除了自己写起来舒服没啥特别优势了.\nVert.x Netty是Jvm上的性能霸主,只要跟性能沾边的就离不开Netty,而Netty过于底层不太适合直接写web框架,最终选用Vert.x(Quarkus,Micronaut封装比Vert.x还是多了些,尽量采用更底层的toolkit而不是现成的framework).\nRedis 无心插柳柳成荫,本意是作为NoSql奈何在缓存方面的光芒掩盖了它本身的定位.\n\n开发环境截止到文章日期,Jdk最新是16,lts长期稳定支持版是11,故我们采用Jdk11.\n\nJdk11\nIdea\nGradle Spring5开始从Maven切到了Gradle,现在新项目没理由用Maven.\n\n命名好的框架从命名开始,复杂难记的框架注定火不起来,经过深思熟虑后框架名为ygo(Yu-Gi-Oh),懂的都懂.\n开搞写框架之前的准备我们都做完了,下一步就来搭建框架的龙骨了.\n","slug":"从零开始撸框架(1)-写在开始之前","date":"2021-04-27T19:27:03.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"}]