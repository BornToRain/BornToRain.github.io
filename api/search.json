[{"id":"b51f3813037c1b7be034f55889123a13","title":"Ros2点云开发(2)-环境搭建(Mac)","content":"前言这篇文章主要还是因为截止到24年3月为止,Ros2(其实Ros1也一样)在arm64架构的Macbook安装都过于麻烦复杂了.\n所需软件开发所需:\n\nMacOs Sonoma 14.0(操作系统)\nRos2 Humble(Robot Operating System机器人操作系统)\nPCL (Point Cloud Library 点云库)\nAnaconda或Miniconda(Python包管理工具)\n\nRos2Mac下安装Ros2过于麻烦,这里推荐使用conda方式.\n1. 下载anaconda或miniconda脚本并执行从Anaconda官网下载对应脚本\n这里我下载的是 Miniconda3-latest-MacOSX-arm64.sh\n12# 执行后一路回车并输入yes完成安装sh Miniconda3-latest-MacOSX-arm64.sh\n\n2. 创建新的conda环境并切换配置123456conda create -n ros_envconda activate ros_env# 给conda源添加ros源conda config --env --add channels conda-forgeconda config --env --add channels robostack-stagingconda config --env --remove channels defaults\n\nconda默认环境并不是ros_env,我们可以把切换环境的命令写入配置文件中来保证生效.\n1echo &#x27;conda activate ros_env&#x27; &gt;&gt; ~/.bashrc\n\n3. 安装Ros2这里得看conda的robostack-staging中ros版本,截止到24年3月,对应版本是humble.\n1conda install ros-humble-desktop\n\n4. 测试(可选)直接运行官方自带的demo即可.\n1ros2 run demo_nodes_cpp talker\n\n\nPCL1. brew安装1brew install pcl\n\n2. 源码安装从PCL Github下载对应版本源码(这里以1.10.0为例).\n12345678910# 解压源码tar xvf pcl-pcl-1.10.0.tar.gz# 在pcl下创建build目录并进入cd pcl-pcl-1.10.0 &amp;&amp; mkdir build &amp;&amp; cd build# 设置安装目录和编译版本cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/pcl-1.10 ..# 多核编译,这里会读取服务器可用核心数.make -j$(nproc)# 安装到前文指定的目录下make install\n\n\n总结Ros2对于Mac尤其是arm架构支持非常不友好,官方不仅不提供二进制文件,连源码安装方式基本都很难跑通,所幸还有conda方法可以成功安装.\n","slug":"Ros2点云开发(2)-环境搭建(Mac)","date":"2024-03-28T08:04:10.000Z","categories_index":"点云","tags_index":"Ros2,PCL,Mac","author_index":"因雨而生"},{"id":"05338416b83a2fce4839c3b86a9b81c3","title":"Ros2点云开发(1)-环境搭建(Ubuntu)","content":"前言记录下开发环境的搭建过程.\n所需软件开发所需:\n\nUbuntu 20.04(操作系统)\nRos2 Foxy(Robot Operating System机器人操作系统)\nPCL 1.10(Point Cloud Library 点云库)\n\nRos2对Ubuntu支持最好,所以首选开发环境为Ubuntu.Ros2和Ubuntu存在版本对应关系.这里我的系统是 Ubuntu20.04,相对应的Ros2版本是 Foxy , PCL 版本为系统apt版本1.10.\nRos21. 添加ros软件源(中科大源)1sudo sh -c &#x27;echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;\n\n2. 添加密钥1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 \n\n3. 更新并升级apt如果源更新慢可以把apt源换成国内的,上面只把ros源替换了而已.\n1sudo apt update &amp;&amp; sudo apt upgrade\n\n4. 安装ros24.1 完整版全家桶(包含ros2本体rviz2以及各种demo和教程)1sudo apt install ros-foxy-desktop python3-argcomplete\n\n4.2 基础开发版(无图形化工具和相关demo教程)1sudo apt install ros-foxy-ros-base python3-argcomplete\n\n4.3 部分非必须库(可选)123456# ros点云与pcl点云转换库sudo apt install ros-foxy-pcl-conversions# ros图像与opencv图像转换库sudo apt install ros-foxy-cv-bridge# ros与前端交互库,websocketsudo apt install ros-foxy-rosbridge-suite\n\n5. 测试(可选)直接运行官方自带的demo即可.\n1ros2 run demo_nodes_cpp talker\n\n6. 设置环境变量(可选)安装完成后将ros脚本添加到环境中,这样不用每次使用前都手动source\n12echo &quot;source /opt/ros/foxy/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n\nPCL1. apt安装1sudo apt install libpcl-dev\n\n2. 源码安装从PCL Github下载对应版本源码(这里以1.10.0为例).\n12345678910# 解压源码tar xvf pcl-pcl-1.10.0.tar.gz# 在pcl下创建build目录并进入cd pcl-pcl-1.10.0 &amp;&amp; mkdir build &amp;&amp; cd build# 设置安装目录和编译版本cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/pcl-1.10 ..# 多核编译,这里会读取服务器可用核心数.make -j$(nproc)# 安装到前文指定的目录下make install\n\n\n总结Ubuntu下安装Ros2和PCL整体都比较简单,唯一需要注意的国外源可能速度慢的问题,其他没啥好说的.\n","slug":"Ros2点云开发(1)-环境搭建(Ubuntu)","date":"2024-03-28T05:40:23.000Z","categories_index":"点云","tags_index":"Ubuntu,Ros2,PCL","author_index":"因雨而生"},{"id":"31ebad76ece9cbfbb4b4be8543fa818d","title":"从零开始撸框架(8)-与Vert.x集成 Web篇(二)","content":"上一篇讲完了全局配置,这一篇我们来讲每个路由的集成.\nVert.x原始使用方式样例来自于Vert.x官网\nVert.x配置api接口1234567public class TestVerticle extends AbstractVerticle &#123;  public void start() throws Exception &#123;    Router router = Router.router(vertx);    route().method(GET).path(&quot;/api1&quot;).consumes(&quot;app/json&quot;).produces(&quot;app/json&quot;).handler().failureHandler();    route().method(GET).path(&quot;/api2&quot;).consumes(&quot;app/json&quot;).produces(&quot;app/json&quot;).handler().failureHandler();  &#125;&#125;\n\n原始使用方式链式编程写起来是很方便,但是全部路由都得写在一起集中管理,对于习惯了传统模式的人很不友好,下面我们来加以改造让它更符合我们更习惯的使用方式.\n改造的话分为以下几个方面:\n\n请求路径\n请求方式\n媒体类型\n响应状态\n请求参数\nhttp工作流\n\n其中1-4为静态解析,即代码编译期我们就能确定值.5-6为动态解析,每次请求它的参数,工作流都不相同,需要我们动态解析去确定.\n下面我们先完成静态解析部分.\n静态解析请求路径首先是第一步,api请求路径解析.\n上文说到了我们会用到jsr311注解,jsr311中是使用 @Path来获取路径的,这里我们写一个工具类来解析@Path注解.Paths.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.btr.ygo.web.kit;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.kit.Fn;import javax.ws.rs.Path;import java.util.Objects;/** * 解析@Path获取请求路径 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class Paths &#123;  public static String resolve(Path path) &#123;    return resolve(path, null);  &#125;  public static String resolve(Path path, String root) &#123;    return Fn.ensureRun(Objects.isNull(root),      // 顶级路径      () -&gt; adjust(path.value()),      () -&gt; &#123;        // 先取上级路径        val rootPath = adjust(root);        // 当前路径        val subPath = adjust(path.value());        // 1 == /        return 1 == rootPath.length() ? subPath : rootPath + subPath;      &#125;);  &#125;  /**   * uri必须是/开头无/结尾,无多//形式.   * ex: / -&gt; /   * ex: /hello -&gt; /hello   * ex: /hello/ -&gt; /hello   * ex: /hello// -&gt; /hello   */  private static String adjust(String path) &#123;    // 多//转单/    var uri = path.replace(&quot;\\\\/+&quot;, &quot;/&quot;);    // 去尾斜杠    if (uri.endsWith(&quot;/&quot;)) uri = uri.substring(0, uri.lastIndexOf(&quot;/&quot;));    // /开头    return  uri.charAt(0) == &#x27;/&#x27; ? uri : &#x27;/&#x27; + uri;  &#125;&#125;\n\n请求方式解析完请求路径开始解析请求方式.jsr311请求方式注解:\n\nGET \nPOST\nPUT\nDELTE\n..\n\n在Trunk.java中追加\n12345678910public final class Trunk &#123;  // 存放的是每个请求方式对应的请求路径集合.  public static final Map&lt;HttpMethod, Set&lt;String&gt;&gt; METHOD_URIS = Map.of(    HttpMethod.GET, new HashSet&lt;&gt;(),    HttpMethod.POST, new HashSet&lt;&gt;(),    HttpMethod.PUT, new HashSet&lt;&gt;(),    HttpMethod.DELETE, new HashSet&lt;&gt;(),    HttpMethod.PATCH, new HashSet&lt;&gt;()  );&#125;\nHttpMehotds.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package org.btr.ygo.web.kit;import io.vertx.core.http.HttpMethod;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.scan.Request;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.HEAD;import javax.ws.rs.OPTIONS;import javax.ws.rs.PATCH;import javax.ws.rs.POST;import javax.ws.rs.PUT;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.Map;/** * 解析@GET..注解获取请求方式 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class HttpMethods &#123;  // jsr311与Vert.x映射关系  private static final Map&lt;Class&lt;?&gt;, HttpMethod&gt; METHODS = Map.of(    GET.class, HttpMethod.GET,    POST.class, HttpMethod.POST,    PUT.class, HttpMethod.PUT,    DELETE.class, HttpMethod.DELETE,    OPTIONS.class, HttpMethod.OPTIONS,    PATCH.class, HttpMethod.PATCH,    HEAD.class, HttpMethod.HEAD  );  public static void resolve(Request req) &#123;    Fn.ensureExec(() -&gt; &#123;      val value = Trunk.METHOD_URIS.get(req.getHttpMethod());      value.add(req.getPath());    &#125;, req.getHttpMethod());  &#125;  public static HttpMethod resolve(Method method) &#123;    val annos = method.getDeclaredAnnotations();    HttpMethod ret = null;    for (Annotation annotation : annos) &#123;      val key = annotation.annotationType();      if (METHODS.containsKey(key)) &#123;        ret = METHODS.get(key);        break;      &#125;    &#125;    return ret;  &#125;&#125;\n\n媒体类型媒体类型同理,jsr311中:\n\n@Consumes 指定请求内容类型(Content-Type). ex: application&#x2F;json;\n@Produces 指定响应内容类型(Accept),不过只有当请求头中Accept包含指定类型才返回.\n\nMediaTypes.java\n1234567891011121314151617181920212223242526272829303132package org.btr.ygo.web.kit;import lombok.val;import javax.ws.rs.Consumes;import javax.ws.rs.Produces;import java.lang.reflect.Method;import java.util.Arrays;import java.util.Objects;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class MediaTypes &#123;  // 默认类型 wildcard  private static final Set&lt;String&gt; DEFAULT = Set.of(&quot;*/*&quot;);  public static Set&lt;String&gt; resolveConsumes(Method method) &#123;    val anno = method.getAnnotation(Consumes.class);    return Fn.ensureRun(Objects.isNull(anno),      () -&gt; DEFAULT,      () -&gt; Arrays.stream(anno.value()).collect(Collectors.toSet()));  &#125;  public static Set&lt;String&gt; resolveProduces(Method method) &#123;    val anno = method.getAnnotation(Produces.class);    return Fn.ensureRun(Objects.isNull(anno),      () -&gt; DEFAULT,      () -&gt; Arrays.stream(anno.value()).collect(Collectors.toSet()));  &#125;&#125;\n\n响应状态响应状态解析于我们自定义注解ResponstStatus.java.\nResponstStatuses.java\n123456789101112131415161718192021package org.btr.ygo.web.kit;import lombok.val;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.web.annotations.ResponseStatus;import org.btr.ygo.web.constant.HttpStatus;import java.lang.reflect.Method;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class ResponstStatuses &#123;  // 这里默认状态返回200 Ok  public static HttpStatus resolveConsumes(Method method) &#123;    val anno = method.getAnnotation(ResponseStatus.class);    return Fn.ensureRun(Objects.isNull(anno), () -&gt; HttpStatus.OK, () -&gt; anno.value());  &#125;&#125;\n\n扫描器继承前文IScanner.java实现以下功能.\n接口扫描器扫描带 @Api的文件,将其标识为接口文件.\nApiScanner.java\n123456789101112131415161718192021222324package org.btr.ygo.web.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.scan.IScanner;import org.btr.ygo.web.annotations.Api;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class ApiScanner implements IScanner&lt;Set&lt;Class&lt;?&gt;&gt;&gt; &#123;  @Override  public Set&lt;Class&lt;?&gt;&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    val ret = classes.stream().filter(d -&gt; d.isAnnotationPresent(Api.class))      .collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;Api&quot;, ret.size());    return ret;  &#125;&#125;\n\n请求扫描器把上述的静态参数扫描,将其转换成Request.java实体类.\nRequestScanner.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package org.btr.ygo.web.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Addr;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.core.kit.Methods;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.core.scan.IScanner;import org.btr.ygo.web.annotations.ResponseStatus;import org.btr.ygo.web.constant.HttpStatus;import org.btr.ygo.web.kit.HttpMethods;import org.btr.ygo.web.kit.MediaTypes;import org.btr.ygo.web.kit.Paths;import javax.ws.rs.Path;import java.lang.reflect.Method;import java.util.Arrays;import java.util.List;import java.util.Objects;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class RequestScanner implements IScanner&lt;List&lt;Request&gt;&gt; &#123;  @Override  public List&lt;Request&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    val ret = classes.stream().flatMap(d -&gt; Fn.ensureRun(!d.isAnnotationPresent(Path.class),      // 顶级uri路径      () -&gt; extract(d, null),      // 非顶级uri路径      () -&gt; extract(d, Paths.resolve(d.getAnnotation(Path.class)))))      .sorted(this::sort)      .collect(Collectors.toList());    log.info(Console.SCANNED, &quot;Request&quot;, ret.size());    return ret;  &#125;  /**   * vert.x路由顺序会影响到接口   * 1. path参数放最后   * 2. 长的放最前面   * ex: /users/:id   *     /users/abc   *     /users   * ret: /users/abc   *      /users   *      /users/:id   */  private int sort(Request x, Request y) &#123;    val xPath = x.getPath();    val yPath = y.getPath();    var b = 0;    if (xPath.contains(Const.COLON)) b = 1;    else if (xPath.length() &gt;= yPath.length()) b = -1;    return b;  &#125;  private Stream&lt;Request&gt; extract(Class&lt;?&gt; cls, String root) &#123;    return Arrays.stream(cls.getDeclaredMethods()).filter(Methods::validateMethod)      .map(d -&gt; extract(d, root));  &#125;  private Request extract(Method method, String root) &#123;    val data = new Request().setMethod(method).setHttpMethod(HttpMethods.resolve(method))      .setConsumes(MediaTypes.resolveConsumes(method))      .setProduces(MediaTypes.resolveProduces(method));    val anno = method.getAnnotation(Path.class);    val path = Fn.ensureRun(Objects.isNull(anno),      () -&gt; root,      () -&gt; Paths.resolve(anno, root));    data.setPath(path);    data.setAddr(method.getAnnotation(Addr.class).value());    data.setProxy(Trunk.getProxy(method.getDeclaringClass()));    val httpStatus = method.getAnnotation(ResponseStatus.class);    // () -&gt; httpStatus.value()不能缩写成httpStatus::value,这里必须lazy.    data.setHttpStatus(      Fn.ensureRun(Objects.isNull(httpStatus), () -&gt; HttpStatus.OK, () -&gt; httpStatus.value()));    return data;  &#125;&#125;\n\n测试把静态部分测试一下\nIScannerTest.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package org.btr.ygo.web.scan;import io.vertx.core.http.HttpMethod;import lombok.val;import org.btr.ygo.core.annotations.Addr;import org.btr.ygo.core.kit.Packages;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.annotations.Api;import org.btr.ygo.web.annotations.ResponseStatus;import org.btr.ygo.web.constant.HttpStatus;import org.hamcrest.CoreMatchers;import org.junit.Assert;import org.junit.Test;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.PUT;import javax.ws.rs.Path;import java.util.Arrays;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public class IScannerTest &#123;  @Api  @Path(&quot;/test&quot;)  public interface TestEventloop &#123;    @GET    @Path(&quot;/hello/:id&quot;)    @Addr(&quot;get&quot;)    void get();    @POST    @Path(&quot;/hello&quot;)    @Addr(&quot;post&quot;)    @ResponseStatus(HttpStatus.CREATED)    void post();    @PUT    @Path(&quot;/users/hello&quot;)    @Addr(&quot;put&quot;)    @ResponseStatus(HttpStatus.ACCEPTED)    void put();    @DELETE    @Path(&quot;/hello/:id&quot;)    @Addr(&quot;delete&quot;)    @ResponseStatus(HttpStatus.NO_CONTENT)    void delete();  &#125;  @Test  public void testApi() &#123;    val classes = Packages.scan();    val scanner = Trunk.&lt;ApiScanner&gt;singleton(ApiScanner.class);    val ret = scanner.scan(classes);    Assert.assertThat(ret, CoreMatchers.hasItem(TestEventloop.class));  &#125;  @Test  public void testRequest() &#123;    val classes = Packages.scan();    val api = Trunk.&lt;ApiScanner&gt;singleton(ApiScanner.class);    val scanner = Trunk.&lt;RequestScanner&gt;singleton(RequestScanner.class);    val ret = scanner.scan(api.scan(classes));    val get = new Request().setAddr(&quot;get&quot;).setPath(&quot;/test/hello/:id&quot;).setHttpMethod(HttpMethod.GET)      .setHttpStatus(HttpStatus.OK);    val post = new Request().setAddr(&quot;post&quot;).setPath(&quot;/test/hello&quot;).setHttpMethod(HttpMethod.POST)      .setHttpStatus(HttpStatus.CREATED);    val put =      new Request().setAddr(&quot;put&quot;).setPath(&quot;/test/users/hello&quot;).setHttpMethod(HttpMethod.PUT)        .setHttpStatus(HttpStatus.ACCEPTED);    val delete =      new Request().setAddr(&quot;delete&quot;).setPath(&quot;/test/hello/:id&quot;).setHttpMethod(HttpMethod.DELETE)        .setHttpStatus(HttpStatus.NO_CONTENT);    val xs = Arrays.asList(get, post, put, delete);    val b = ret.stream().allMatch(x -&gt; xs.stream().anyMatch(y -&gt; compare(x, y)));    Assert.assertTrue(b);  &#125;  private boolean compare(Request x, Request y) &#123;    return x.getPath().equals(y.getPath()) &amp;&amp; x.getAddr().equals(y.getAddr()) &amp;&amp;      x.getHttpMethod().equals(y.getHttpMethod()) &amp;&amp; x.getHttpStatus().equals(y.getHttpStatus());  &#125;&#125;\n\n测试结果\n\n动态解析请求参数请求参数解析分为两步.\n\n注解解析: 根据注解决定调用何种解析方式,最典型的例子就是分别带有 @PathParam、*@BodyParam*注解的参数.\n类型解析: 根据类型决定调用何种类型转换方式.\n\n根据上面我们可以抽象出两个接口.\n基类IParamParser.java\n12345678910111213141516171819202122232425package org.btr.ygo.web.parse;import io.vertx.ext.web.RoutingContext;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.annotations.BodyParam;import java.lang.reflect.Parameter;import java.util.HashMap;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IParamParser &#123;  // 表驱动模式  Map&lt;Class&lt;?&gt;, IParamParser&gt; MAP = new HashMap&lt;&gt;() &#123;&#123;    // 根据请求参数上的注解选用对应的参数解析器    put(BodyParam.class, Trunk.singleton(BodyParamParser.class));  &#125;&#125;;  static IParamParser get(Class&lt;?&gt; key) &#123;    // 找不到解析器默认采用Body解析器    return MAP.getOrDefault(key, Trunk.singleton(BodyParamParser.class));  &#125;  Object parse(RoutingContext context, Parameter param);&#125;\n\nIConvert.java\n12345678910111213141516171819202122232425package org.btr.ygo.web.convert;import io.vertx.core.json.JsonObject;import org.btr.ygo.core.kit.Trunk;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IConvert &#123;  // 表驱动模式  Map&lt;Class&lt;?&gt;, IConvert&gt; MAP = new HashMap&lt;&gt;() &#123;&#123;    // 根据key选用对应的转换器实现    put(int.class, Trunk.singleton(IntConvert.class));    put(Integer.class, Trunk.singleton(IntConvert.class));  &#125;&#125;;  static IConvert get(Class&lt;?&gt; key) &#123;    // 找不到可用转换器,默认调用字符串转换器.    return MAP.getOrDefault(key, Trunk.singleton(StringConvert.class));  &#125;  Object convert(String str);&#125;\n\n具体实现挨个实现比较长,这里我仅以解析 @BodyParam注解和参数类型为Int的代码为例.\nIntConvert.java\n12345678910111213package org.btr.ygo.web.convert;import org.btr.ygo.core.kit.Fn;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class IntConvert implements IConvert &#123;  @Override  public Object convert(String str) &#123;    return Fn.ensureRun(() -&gt; Integer.parseInt(str), str);  &#125;&#125;\n\nBodyParamParser.java\n1234567891011121314151617package org.btr.ygo.web.parse;import io.vertx.ext.web.RoutingContext;import org.btr.ygo.web.convert.IConvert;import java.lang.reflect.Parameter;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class BodyParamParser implements IParamParser &#123;  @Override  public Object parse(RoutingContext context, Parameter param) &#123;    // 通过字段类型找到转换器开始转换请求参数值.    return IConvert.get(param.getType()).convert(context.getBodyAsString());  &#125;&#125;\n\n多种注解以及类型解析只需挨个继承实现IParamParser.java和IConvert.java即可.\nhttp工作流一次http请求响应过程如下:\n\n接收请求 \n解析请求路径、方式、媒体类型等…各个参数(静态解析部分)\n调用函数处理(Async、Sync、Rx…等反射调用)\nReactor结构请求(Vert.x中用EventBus实现)\n根据请求头返回对应数据结构数据(Json、Xml、Text、二进制…不同响应策略)\n\n根据上述写出接口.\n基类响应工具类.\nResponds.java\n12345678910111213141516171819202122232425262728293031package org.btr.ygo.web.kit;import io.vertx.core.http.HttpServerResponse;import io.vertx.ext.web.RoutingContext;import lombok.val;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.web.constant.HttpStatus;import org.btr.ygo.web.scan.Request;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class Responds &#123;  public static void failed(RoutingContext context, Throwable ex) &#123;    if (Objects.nonNull(ex)) ex.printStackTrace();    val rep = context.response();    if (!rep.closed()) rep.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.code)      .setStatusMessage(HttpStatus.INTERNAL_SERVER_ERROR.msg);  &#125;  public static HttpServerResponse succeed(RoutingContext context, Request req) &#123;    val rep = context.response();    return Fn.ensureRun(rep.closed(),      () -&gt; rep,      () -&gt; &#123;        val httpStatus = req.getHttpStatus();        return rep.setStatusCode(httpStatus.code).setStatusMessage(httpStatus.msg);      &#125;);  &#125;&#125;\n\n响应数据结构接口,根据不同结构实现不同子类.\nIRepStruct.java\n12345678910111213141516171819202122232425262728package org.btr.ygo.web.struct;import io.vertx.core.http.HttpServerResponse;import org.btr.ygo.core.kit.Trunk;import javax.ws.rs.core.MediaType;import java.util.HashMap;import java.util.Map;/** * 响应数据结构 * 1. Json * 2. Xml * 3. Text * 4. 二进制 * ... * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface RepStruct &#123;  Map&lt;String, RepStruct&gt; MAP = new HashMap&lt;&gt;() &#123;&#123;    put(MediaType.APPLICATION_JSON, Trunk.singleton(JsonRepStruct.class));    put(MediaType.TEXT_HTML, Trunk.singleton(TextRepStruct.class));  &#125;&#125;;  static RepStruct get(String key) &#123;    return MAP.getOrDefault(key, Trunk.singleton(JsonRepStruct.class));  &#125;  void respond(HttpServerResponse rep, Object ret);&#125;\n\nhttp流接口,子类实现不同http工作流程.\nIHttpFlow.java\n1234567891011121314151617181920212223242526272829package org.btr.ygo.web;import io.vertx.core.Future;import io.vertx.core.Handler;import io.vertx.ext.web.RoutingContext;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.scan.Request;import java.util.HashMap;import java.util.Map;/** * http工作流 * 1. 接收请求 * 2. 解析请求路径、方式、媒体类型等...各个参数 * 3. 调用函数处理(Async、Sync、Rx...) * 4. Reactor结构请求(Vert.x中用EventBus实现) * 5. 根据请求头返回对应数据结构数据(Json、Xml、Text、二进制...) * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IFlow &#123;  Map&lt;Class&lt;?&gt;, IFlow&gt; MAP = new HashMap&lt;&gt;() &#123;&#123;    put(Future.class, Trunk.singleton(FutureFlow.class));  &#125;&#125;;  static IFlow get(Class&lt;?&gt; key) &#123;    return MAP.getOrDefault(key, Trunk.singleton(FutureFlow.class));  &#125;  Handler&lt;RoutingContext&gt; handle(Request req);&#125;\n\n具体实现这里仅实现Vert.x中的Future响应流与Json数据结构.\nJsonRepStruct.java\n1234567891011121314151617package org.btr.ygo.web.struct;import io.vertx.core.http.HttpServerResponse;import io.vertx.core.json.Json;import org.btr.ygo.core.kit.Fn;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class JsonRepStruct implements RepStruct &#123;  @Override  public void respond(HttpServerResponse rep, Object ret) &#123;    Fn.ensureRun(Objects.nonNull(ret), () -&gt; rep.end(Json.encode(ret)), rep::end);  &#125;&#125;\n\nFutureHttpFlow.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.btr.ygo.web.flow;import io.vertx.core.Handler;import io.vertx.ext.web.RoutingContext;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.core.kit.Reflect;import org.btr.ygo.core.kit.Verticles;import org.btr.ygo.web.kit.Responds;import org.btr.ygo.web.parse.IParamParser;import org.btr.ygo.web.scan.Request;import org.btr.ygo.web.struct.RepStruct;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class FutureFlow implements IFlow &#123;  @Override  public Handler&lt;RoutingContext&gt; handle(Request req) &#123;    return context -&gt; &#123;      // 1. 解析参数      val args = IParamParser.parseArgs(context, req);      // 2. 调用函数(Async,Sync,Rx...)      val method = req.getMethod();      val methodName = method.getName();      val ret = Reflect.invokeMethod(req.getProxy(), methodName, args);      log.info(Console.INVOKE, method.getDeclaringClass(), methodName, Fn.join(Const.COMMA, args));      // 3. event-bus请求(reactor结构)      val future = context.vertx().eventBus().request(req.getAddr(), ret, Verticles.delivery());      future.onComplete(ar -&gt; &#123;        if (ar.failed()) Responds.failed(context, ar.cause());        else &#123;          // 4. 响应数据结构(Json,Xml,Text...)          val struct = RepStruct.get(context.getAcceptableContentType());          struct.respond(Responds.succeed(context, req), ar.result().body());        &#125;      &#125;);    &#125;;  &#125;&#125;\n\n重构前文的EventloopHttpActor.java,把动态参数解析加上.\nEventloopHttpActor.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package org.btr.ygo.web.actor;import io.vertx.core.AbstractVerticle;import io.vertx.core.http.HttpMethod;import io.vertx.core.http.HttpServerOptions;import io.vertx.ext.web.Route;import io.vertx.ext.web.Router;import io.vertx.ext.web.handler.BodyHandler;import io.vertx.ext.web.handler.CorsHandler;import io.vertx.ext.web.handler.ResponseContentTypeHandler;import io.vertx.ext.web.handler.SessionHandler;import io.vertx.ext.web.handler.TimeoutHandler;import io.vertx.ext.web.sstore.ClusteredSessionStore;import io.vertx.ext.web.sstore.LocalSessionStore;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Eventloop;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.config.CorsConfig;import org.btr.ygo.web.config.Server;import org.btr.ygo.web.constant.Console;import org.btr.ygo.web.flow.IFlow;import org.btr.ygo.web.kit.Deck;import org.btr.ygo.web.kit.Network;import org.btr.ygo.web.scan.Request;import java.lang.reflect.Method;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@Eventlooppublic final class EventloopHttpActor extends AbstractVerticle &#123;  @Override  public void start() throws Exception &#123;    Deck.HTTP_SERVERS.forEach((port, config) -&gt; &#123;      val router = Router.router(vertx);      configRouter(router);      configRequest(router);      server(router, port, config);    &#125;);  &#125;  private void configRouter(Router router) &#123;    val store =      vertx.isClustered() ? ClusteredSessionStore.create(vertx) : LocalSessionStore.create(vertx);    val cors = Trunk.&lt;CorsConfig&gt;singleton(CorsConfig.class).read();    // POST|PUT请求才接收body,其他不接收解析更快.    router.route().method(HttpMethod.POST).method(HttpMethod.PUT).handler(BodyHandler.create())      // 全局默认超时: 5s      .handler(TimeoutHandler.create())      .handler(ResponseContentTypeHandler.create())      .handler(SessionHandler.create(store))      // 跨域      .handler(CorsHandler.create(cors.getOrigin()).allowCredentials(cors.getAllowCredentials())        .allowedHeaders(cors.getAllowedHeaders()).allowedMethods(cors.getAllowedMethods()));  &#125;  private void server(Router router, Integer port, Server config) &#123;    val options = new HttpServerOptions(config.getOptions());    vertx.createHttpServer(options).requestHandler(router).listen();    // 发布api地址    val path = &quot;http://&quot; + Network.getIPv4() + Const.COLON + port + Const.SLASH;    log.info(Console.SERVER, getClass().getSimpleName(), Const.HTTP, path);  &#125;  private void configRequest(Router router) &#123;    Deck.REQUESTS.forEach(req -&gt; &#123;      val route = router.route(req.getHttpMethod(), req.getPath());      timeoutIf(req, route);      mediaTypeIf(req, route);      setHandler(req, route);    &#125;);  &#125;  private void timeoutIf(Request req, Route route) &#123;    val timeout = req.getTimeout();    if (Objects.nonNull(timeout) &amp;&amp; timeout &gt; 0) route.handler(TimeoutHandler.create(timeout));  &#125;  private void mediaTypeIf(Request req, Route route) &#123;    req.getConsumes().forEach(route::consumes);    req.getProduces().forEach(route::produces);  &#125;  private void setHandler(Request req, Route route) &#123;    val method = findReceipter(req);    // TODO 目前只支持Async/Sync    val handler = IFlow.get(method.getReturnType()).handle(req);    route.handler(handler);  &#125;  private Method findReceipter(Request req) &#123;    val addr = req.getAddr();    val receipt =      Trunk.RECEIPTS.stream().filter(d -&gt; d.getAddr().equals(addr))        .findAny().orElseThrow(() -&gt; new NullPointerException(        &quot;No method under the @EventBus class for the @Addr annotation value &quot; + addr +          &quot; was found&quot;));    return receipt.getMethod();  &#125;&#125;\n\n\n总结这一篇我们把Vert.x中路由使用改造成我们最熟悉的Spring注解式开发模式了,以后使用的话更加顺手习惯.\n","slug":"从零开始撸框架(8)-与Vert.x集成 Web篇(二)","date":"2021-05-12T06:33:24.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java,代理模式","author_index":"因雨而生"},{"id":"c38b17588d251cd9846139dacf4f50ed","title":"从零开始撸框架(7)-与Vert.x集成 Web篇(一)","content":"上一篇讲完了与Vert.x集成的整体情况,这一篇开始与vertx-web集成.\n这些内容我们主要在web模块中进行开发.\nWeb全局集成web组件下的build.gradlebuild.gradle\n1234567dependencies &#123;  // 核心组件  compile project(&quot;:core&quot;)  compile &quot;io.vertx:vertx-web:$vertxVersion&quot;    // jsr311    &quot;javax.ws.rs:javax.ws.rs-api:2.1.1&quot;&#125;\n\n注解核心组件注解我们是基于jsr330,web组件这我们基于jsr311+自定义注解.\n字段级\n@PathParam 原生注解,获取地址栏参数.\n@QueryParam 原生注解,获取QuerySring.\n@CookieParam 原生注解,获取Cookie.\n@HeaderParam 原生注解,获取Header.\n@BodyParam 自定义注解,获取请求体,与Spring中的 @RequestBody 同含义.\n@SessionParam 自定义注解,获取Session.\n@ResponseStatus 自定义注解,设置默认响应http状态码.\n\n这里只放出自定义注解代码.BodyParam.java\n123456789101112131415161718package org.btr.ygo.web.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Target(&#123;ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface BodyParam &#123;&#125;\nSessionParam.java\n12345678910111213141516171819package org.btr.ygo.web.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface SessionParam &#123;  String value();&#125;\nResponseStatus.java\n1234567891011121314151617181920212223package org.btr.ygo.web.annotations;import org.btr.ygo.web.constant.HttpStatus;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD,ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)public @interface ResponseStatus &#123;  HttpStatus value() default HttpStatus.INTERNAL_SERVER_ERROR;  HttpStatus code() default HttpStatus.INTERNAL_SERVER_ERROR;  String msg() default &quot;&quot;;&#125;\n\n类级\n@Api 自定义注解,标识当前类是一个Api,与Spring中的 @Controller 同含义.\n\nApi.java\n123456789101112131415161718package org.btr.ygo.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)public @interface Api &#123;&#125;\n\n配置web服务配置多种多样,我们也需要定义对应的实体类.\ncors配置对象Cors.java\n1234567891011121314151617181920212223package org.btr.ygo.web.config;import io.vertx.core.http.HttpMethod;import lombok.AccessLevel;import lombok.Data;import lombok.experimental.Accessors;import lombok.experimental.FieldDefaults;import java.util.Set;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Data@Accessors(chain = true)@FieldDefaults(level = AccessLevel.PRIVATE)public class Cors &#123;  String origin;  Boolean allowCredentials;  Set&lt;HttpMethod&gt; allowedMethods;  Set&lt;String&gt; allowedHeaders;&#125;\n\n配置读取CorsConfig.java\n12345678910111213141516171819202122232425262728293031323334353637package org.btr.ygo.web.config;import io.vertx.core.http.HttpMethod;import io.vertx.core.json.JsonArray;import io.vertx.core.json.JsonObject;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.config.IConfig;import org.btr.ygo.core.config.YgoConfig;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Trunk;import java.util.Set;import java.util.function.Function;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class CorsConfig implements IConfig&lt;Cors&gt; &#123;  @Override  public Cors read() &#123;    val config = Trunk.&lt;YgoConfig&gt;singleton(YgoConfig.class).read();    return read(config.getJsonObject(Const.VERTX).getJsonObject(&quot;cors&quot;));  &#125;  public Cors read(JsonObject json) &#123;    return new Cors().setOrigin(json.getString(&quot;origin&quot;))      .setAllowCredentials(json.getBoolean(&quot;allow-credentials&quot;))      .setAllowedHeaders(toSet(json.getJsonArray(&quot;allowed-headers&quot;), Object::toString))      .setAllowedMethods(toSet(json.getJsonArray(&quot;allowed-methods&quot;),          d -&gt; new HttpMethod(d.toString().toUpperCase())));  &#125;  private &lt;T&gt; Set&lt;T&gt; toSet(JsonArray xs, Function&lt;Object, T&gt; fn) &#123;    return xs.stream().map(fn).collect(Collectors.toSet());  &#125;&#125;\n\n配置示例application.yaml\n1234567891011121314151617181920ygo:  profile: default  vertx:    name: vertx-ygo    options:      haEnabled: false      preferNativeTransport: true    cors:      origin: &quot;*&quot;      allow-credentials: true      allowed-methods:        - GET        - POST        - PUT        - DELETE        - PATCH        - OPTIONS        - HEAD      allowed-headers:        - Content-Type\n\n类、配置定义一个对象,用来装请求的各种参数.\nRequest.java\n123456789101112131415161718192021222324252627282930313233package org.btr.ygo.web.scan;import io.vertx.core.http.HttpMethod;import lombok.AccessLevel;import lombok.Data;import lombok.experimental.Accessors;import lombok.experimental.FieldDefaults;import org.btr.ygo.web.constant.HttpStatus;import java.lang.reflect.Method;import java.util.Set;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Data@Accessors(chain = true)@FieldDefaults(level = AccessLevel.PRIVATE)public class Request &#123;  // 请求uri路径.  String path;  HttpMethod httpMethod;  HttpStatus httpStatus;  Long timeout;  // 对应类中所需要执行的函数  Method method;  Set&lt;String&gt; consumes;  Set&lt;String&gt; produces;  // 代理类,一般是XxxApi,XxxController,XxxAgent.  Object proxy;  // 对应EventBus中的地址.  String addr;&#125;\nDeck.java追加\nDeck.java\n123456public final class Deck &#123;  // 所有包含@Api注解类  public static final Set&lt;Class&lt;?&gt;&gt; APIS = new HashSet&lt;&gt;();  // 所有的  public static final List&lt;Request&gt; REQUESTS = new ArrayList&lt;&gt;();&#125;\n\n把上一篇中的EventloopHttpActor.java重构一下. 在里面把Router全局配置加上.EventloopHttpActor.java\n123456789101112131415161718192021222324252627public final class EventloopHttpActor extends AbstractVerticle &#123;  @Override  public void start() throws Exception &#123;    Deck.HTTP_SERVERS.forEach((port, config) -&gt; &#123;      val router = Router.router(vertx);      configRouter(router);      server(router, port, config);    &#125;);  &#125;  // router的整体参数配置  private void configRouter(Router router) &#123;    // 集群还是本地存储    val store =      vertx.isClustered() ? ClusteredSessionStore.create(vertx) : LocalSessionStore.create(vertx);    val cors = Trunk.&lt;CorsConfig&gt;singleton(CorsConfig.class).read();    // POST|PUT请求才接收body,其他不接收解析更快.    router.route().method(HttpMethod.POST).method(HttpMethod.PUT).handler(BodyHandler.create())      // 全局默认超时: 5s      .handler(TimeoutHandler.create())      .handler(ResponseContentTypeHandler.create())      .handler(SessionHandler.create(store))      // 跨域      .handler(CorsHandler.create(cors.getOrigin()).allowCredentials(cors.getAllowCredentials())        .allowedHeaders(cors.getAllowedHeaders()).allowedMethods(cors.getAllowedMethods()));  &#125;  ...&#125; \n\n\n总结这一篇完成了vertx-web的全局配置,使用时会应用到vertx-web下的所有请求.\n","slug":"从零开始撸框架(7)-与Vert.x集成 Web篇(一)","date":"2021-05-10T06:50:32.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java,代理模式","author_index":"因雨而生"},{"id":"a0a429763c9944ec54d86de5e0e4f445","title":"从零开始撸框架(6)-与Vert.x集成 基础篇(二)","content":"这一章我们来将上一章中的 Verticle 在Vert.x中运行起来.\nVert.x原始使用方式样例来自于Vert.x官网\n部署Verticle并运行Vert.x1234567891011public class HelloWorld &#123;  public static void main() &#123;    // 单例    // Vertx vertx = Vertx.vertx();    // 集群    Vertx.clusteredVertx(options, ar -&gt; &#123;      val vertx = ar.result();      vertx.deployVerticle(Server.class.getName());    &#125;);  &#125;&#125;\n\n这里贴出来方便参考,下面开始与Vert.x的集成.\nVert.x集成基类辅助类线程类,单纯为了打印线程名.可省略\nThreads.java\n1234567891011121314package org.btr.ygo.web.kit;import lombok.val;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class Threads &#123;  public static void run(Runnable runnable, String name) &#123;    val thread = new Thread(runnable);    thread.setName(name + &quot;-&quot; + thread.getId());    thread.start();  &#125;&#125;\n\n\n本体框架启动入口类\nILauncher.java\n123456789101112131415161718package org.btr.ygo.web;import io.vertx.core.Vertx;import java.util.function.Consumer;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface ILauncher &#123;  /**   * 这里为什么要采用Java8的Consumer为参数,而不是Vertx或者Supplier&lt;Vertx&gt;呢.   * 1. 这里我们希望Vert.x是子类去创建(单例、集群)Vert.x,而不是外界创建好后传进来. start(Vertx vertx); (×)   * 2. 创建的Vert.x我们后续会用到,所以需要返回或者能使用到,   *    而单例、集群模式的Vert.x返回值一个Sync一个Future,用Supplier&lt;Vertx&gt;不好操作. start(Supplier&lt;Vertx&gt; fn); (×)    */  void start(Consumer&lt;Vertx&gt; fn);&#125;\n\nActorLauncher.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.btr.ygo.web;import io.netty.util.internal.logging.InternalLoggerFactory;import io.netty.util.internal.logging.Log4J2LoggerFactory;import io.vertx.core.Vertx;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.config.VertxConfig;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.constant.Console;import java.util.function.Consumer;import static io.vertx.core.spi.resolver.ResolverProvider.DISABLE_DNS_RESOLVER_PROP_NAME;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class ActorLauncher implements ILauncher &#123;  @Override  public void start(Consumer&lt;Vertx&gt; fn) &#123;    // 读取Vert.x相关配置    val config = Trunk.&lt;VertxConfig&gt;singleton(VertxConfig.class);    val options = config.read();    // 将Vert.x的日志换成Log4j2    InternalLoggerFactory.setDefaultFactory(Log4J2LoggerFactory.INSTANCE);    // 墙,dns解析最好关掉.    System.getProperties().setProperty(DISABLE_DNS_RESOLVER_PROP_NAME, &quot;true&quot;);    Fn.ensureExec(!options.isHAEnabled(),      // 单例      () -&gt; &#123;        log.info(Console.SINGLE, options.toJson().encodePrettily());        fn.accept(Vertx.vertx(options));      &#125;,      // 集群      () -&gt; &#123;        val manager = options.getClusterManager();        log.info(Console.LAUNCHER, manager, manager.getNodeId(), manager.isActive());        Vertx.clusteredVertx(options, ar -&gt; &#123;          val vertx = ar.result();          fn.accept(vertx);        &#125;);      &#125;);  &#125;&#125;\n\n启动入口模仿Spring-boot 的SpringApplication.run写一个.\nVertxBootstrap.java\n12345678910111213141516171819202122232425262728293031package org.btr.ygo.web;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.actor.EventloopActor;import org.btr.ygo.core.actor.WorkerActor;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.web.kit.Threads;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class VertxBootstrap &#123;  public static void run() &#123;    new VertxBootstrap().start();  &#125;  public void start() &#123;    val launcher = Trunk.&lt;ActorLauncher&gt;singleton(ActorLauncher.class);    launcher.start(vertx -&gt; &#123;      Threads.run(() -&gt; &#123;        val master = Trunk.&lt;EventloopActor&gt;singleton(EventloopActor.class);        master.integration(vertx);      &#125;, &quot;ygo-eventloop-thread&quot;);      Threads.run(() -&gt; &#123;        val worker = Trunk.&lt;WorkerActor&gt;singleton(WorkerActor.class);        worker.integration(vertx);      &#125;, &quot;ygo-worker-thread&quot;);    &#125;);  &#125;&#125;\n\n测试在 &#x2F;test&#x2F;main&#x2F;resources 、 &#x2F;test&#x2F;main&#x2F;resources&#x2F;ygo&#x2F; 目录下分别添加 application.yaml 文件.application.yaml\n12345678ygo:  name: test  profile: default  vertx:    name: vertx-ygo    options:      haEnabled: false      preferNativeTransport: true\n\n启动测试类VertxBootstrapTest.java\n12345678910111213package org.btr.ygo.web;import org.junit.Test;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public class VertxBootstrapTest &#123;  @Test  public void test() &#123;    VertxBootstrap.run();  &#125;&#125;\n\n测试结果\n总结到此框架与Vert.x基础集成完成了,现在框架中的类、配置已经被识别成Verticle并运行在Vert.x中了.\n下一篇我们就要开始集成Vert.x-web来实现框架Web部分的功能了.\n","slug":"从零开始撸框架(6)-与Vert.x集成 基础篇(二)","date":"2021-05-07T03:54:00.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java,代理模式","author_index":"因雨而生"},{"id":"6b0291adc1983f086f545c1304c40edc","title":"从零开始撸框架(5)-与Vert.x集成 基础篇(一)","content":"前两章我们分别讲完了类、配置,让框架有了骨架.接下来几章我们要实现类、配置与Vert.x集成,让框架跑在Vert.x中.\n由于接下来会设计到对外提供web服务了,篇幅会比较长.这里我决定分篇,第一篇先把大体的讲完,剩下几篇再讲web方面的细节.\nVert.x原始使用方式样例来自于Vert.x官网\n编写Verticle1234567891011import io.vertx.core.AbstractVerticle;public class Server extends AbstractVerticle &#123;  public void start() &#123;    vertx.createHttpServer().requestHandler(req -&gt; &#123;      req.response()        .putHeader(&quot;content-type&quot;, &quot;text/plain&quot;)        .end(&quot;Hello from Vert.x!&quot;);    &#125;).listen(8080);  &#125;&#125;\n\n这里贴出来方便参考,下面开始与Vert.x的集成.\n\nVert.x集成基类辅助类工具集成中,不管是 Eventloop 还是 Worker 都会用到一些重复的方法,只是部分参数不同,我们把它做成工具类.Verticles.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.btr.ygo.core.kit;import io.vertx.core.DeploymentOptions;import io.vertx.core.Vertx;import io.vertx.core.eventbus.DeliveryOptions;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.constant.Const;import java.util.HashMap;import java.util.Map;import java.util.Objects;/** * Vert.x Vertcile部署 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class Verticles &#123;  // value - verticle id  private static final Map&lt;Class&lt;?&gt;, String&gt; VERTICLES = new HashMap&lt;&gt;();  private static String flag(boolean isWorker) &#123;    return isWorker ? Const.WORKER : Const.EVENTLOOP;  &#125;  public static void deploy(Vertx vertx, DeploymentOptions options, Class&lt;?&gt; cls) &#123;    val name = cls.getName();    val flag = flag(options.isWorker());    vertx.deployVerticle(cls.getName(), options, ar -&gt; &#123;      val id = ar.result();      val instances = options.getInstances();      if (ar.succeeded()) &#123;        log.info(Console.DEPLOYED_S, flag, name, instances, id);        VERTICLES.put(cls, id);      &#125;      else &#123;        val cause = ar.cause();        if (Objects.nonNull(cause)) cause.printStackTrace();        val msg = Objects.isNull(cause) ? null : cause.getMessage();        log.warn(Console.DEPLOYED_F, flag, name, id, instances, msg);      &#125;    &#125;);  &#125;  public static void undeploy(Vertx vertx, Class&lt;?&gt; cls, String flag) &#123;    val id = VERTICLES.get(cls);    val name = cls.getName();    vertx.undeploy(id, ar -&gt; &#123;      if (ar.succeeded()) log.info(Console.UNDEPLOYED_S, flag, name, id);      else &#123;        val cause = ar.cause();        if (Objects.nonNull(cause)) cause.printStackTrace();        val msg = Objects.isNull(cause) ? null : cause.getMessage();        log.warn(Console.UNDEPLOYED_F, flag, name, id, msg);      &#125;    &#125;);  &#125;  public static DeliveryOptions delivery() &#123;    return new DeliveryOptions();  &#125;&#125;\n\n类、配置当然也会用到我们之前加载好的类、配置.Trunk.java\n12345678910public final class Trunk &#123;  ...  // 所有@Eventloop类  public static final Set&lt;Class&lt;?&gt;&gt; EVENTLOOPS = new HashSet&lt;&gt;();  // 所有@Worker类  public static final Set&lt;Class&lt;?&gt;&gt; WORKERS = new HashSet&lt;&gt;();  // 所有Vert.x EventBus上的对象  public static final Set&lt;Receipt&gt; RECEIPTS = new HashSet&lt;&gt;();  ...&#125;\nDeck.java\n12345678public final class Deck &#123;  ...  // 所有http服务配置  public static final Map&lt;Integer, Server&gt; HTTP_SERVERS = new HashMap&lt;&gt;();  // 所有tcp服务配置  public static final Map&lt;Integer, Server&gt; NET_SERVERS = new HashMap&lt;&gt;();  ...&#125;\nReflect.java\n123456789101112public final class Reflect &#123;  ...  private static final Map&lt;Class&lt;?&gt;, MethodAccess&gt; METHODS = new HashMap&lt;&gt;();  // 反射执行对应的方法  public static &lt;T&gt; T invokeMethod(Object instance, String name, Object... args) &#123;    return Fn.ensureRun(() -&gt; &#123;      val instanceCls = instance.getClass();      val access = Fn.pool(METHODS, instanceCls, () -&gt; MethodAccess.get(instanceCls));      return (T) access.invoke(instance, name, args);    &#125;, instance, name);  &#125;&#125;\n\n本体IActor是框架与Vert.x的连接桥梁,子类继承该类就可以获得Vert.x框架中的Vert.x对象.\nIActor.java\n12345678910package org.btr.ygo.core.actor;import io.vertx.core.Vertx;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IActor &#123;  void integration(Vertx vertx);&#125;\n\nVert.x中最小工作单位Verticle为一个类,它的配置参数io.vertx.core.DeploymentOptions就是根据该类获取的,这里我们可以得出一个Verticle配置参数提取基类.\nIExtractor.java\n1234567891011package org.btr.ygo.core.actor;import io.vertx.core.DeploymentOptions;/** * 根据类名获取相应的配置 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IExtractor &#123;  DeploymentOptions extract(Class&lt;?&gt; cls);&#125;\n\nVert.x通信是通过eventbus交互的,这里我们也抽象出一个基类,后续可以实现异步(Future)、同步(Sync)、响应式(Rx)应答,当前我们仅实现Future.\nIReplier.java\n1234567891011121314151617181920212223package org.btr.ygo.core.actor;import io.vertx.core.Future;import io.vertx.core.eventbus.Message;import org.btr.ygo.core.kit.Trunk;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IReplier &#123;  // 定义一个map,用于表驱动选取对应的应答模式,默认是Future.  Map&lt;Class&lt;?&gt;, IReplier&gt; MAP = new HashMap&lt;&gt;() &#123;&#123;    put(Future.class, Trunk.singleton(FutureReplier.class));  &#125;&#125;;  static IReplier get(Class&lt;?&gt; key) &#123;    return MAP.getOrDefault(key, Trunk.singleton(FutureReplier.class));  &#125;  void reply(Object proxy, Method method, Message&lt;Object&gt; message);&#125;\n\nFutureReplier.java\n12345678910111213141516171819202122232425262728package org.btr.ygo.core.actor;import io.vertx.core.Future;import io.vertx.core.eventbus.Message;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.kit.Reflect;import org.btr.ygo.core.kit.Verticles;import java.lang.reflect.Method;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class FutureReplier implements IReplier &#123;  @Override  public void reply(Object proxy, Method method, Message&lt;Object&gt; message) &#123;    // 因为是Future响应,返回值的形式是Future&lt;?&gt;,光靠method.getReturnType()是拿不到具体泛型的.    val retType = method.getGenericReturnType();    log.info(Console.REPLY, getClass(), retType, false);    // 反射执行方法    Reflect.&lt;Future&lt;?&gt;&gt;invokeMethod(proxy, method.getName(), message)      // 执行完成,开始应答.      .onComplete(ar -&gt; message.reply(ar.result(), Verticles.delivery()));  &#125;&#125;\n\n\nEventloop集成本体EventloopExtractor.java\n12345678910111213141516171819202122232425262728293031323334353637383940package org.btr.ygo.core.actor;import io.vertx.core.DeploymentOptions;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Eventloop;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Fn;import java.util.HashMap;import java.util.Map;/** * Eventloop类的Verticle参数提取 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class EventloopExtractor implements IExtractor &#123;  private static final Map&lt;Class&lt;?&gt;, DeploymentOptions&gt; OPTIONS = new HashMap&lt;&gt;();  @Override  public DeploymentOptions extract(Class&lt;?&gt; cls) &#123;    log.info(Console.DEPLOY, Const.EVENTLOOP, cls.getName());    return Fn.pool(OPTIONS, cls, () -&gt; extractValue(cls));  &#125;  private DeploymentOptions extractValue(Class&lt;?&gt; cls) &#123;    val anno = cls.getAnnotation(Eventloop.class);    val options =      new DeploymentOptions().setHa(anno.ha()).setInstances(anno.instances()).setWorker(false);    if (!OPTIONS.isEmpty()) &#123;      val latest = OPTIONS.getOrDefault(cls, new DeploymentOptions());      val oldest = options.toJson();      oldest.mergeIn(latest.toJson(), true);      return new DeploymentOptions(oldest);    &#125;    log.info(Console.DEPLOYED, Const.EVENTLOOP, options.getInstances(), options.isHa(),      options.toJson());    return options;  &#125;&#125;\n\nEventloopActor.java\n1234567891011121314151617181920212223242526272829303132package org.btr.ygo.core.actor;import io.vertx.core.Vertx;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.constant.EventloopType;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.core.kit.Verticles;import java.util.HashMap;import java.util.Map;/** * eventloop集合与Vert.x集成 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class EventloopActor implements IActor &#123;  // 这里定义一个集合,因为eventloop目前总共有三类, http、tcp、sock.  public static final Map&lt;EventloopType, Class&lt;?&gt;&gt; EVENTLOOPS = new HashMap&lt;&gt;();  @Override  public void integration(Vertx vertx) &#123;    // 配置提取器    val extractor = Trunk.&lt;EventloopExtractor&gt;singleton(EventloopExtractor.class);    // 循环作为Verticle部署到Vert.x中    EVENTLOOPS.forEach((type, cls) -&gt; Verticles.deploy(vertx, extractor.extract(cls), cls));    // 钩子,优雅从Vert.x中卸载对应的Verticle.    Runtime.getRuntime().addShutdownHook(new Thread(      () -&gt; EVENTLOOPS.forEach((type, cls) -&gt; Verticles.undeploy(vertx, cls, Const.EVENTLOOP))));  &#125;&#125;\n\nEventloop类型分为http、tcp、sock分类,这里我们实现一个http.\nhttp实现http我们只实现任务调度部分.\nhttp非vertx-core内容,这里我们新建一个web模块,接下来web方面内容都在该模块下写.\nbuild.gradle(web模块下)\n123456dependencies &#123;  // 依赖核心组件  compile project(&quot;:core&quot;)  // 追加vertx-web  compile &quot;io.vertx:vertx-web:$vertxVersion&quot;&#125;\n\nhttp配置新建两个Java文件,一个是配置对象,一个是继承自前两章的IConfig接口来实现配置读取.\n配置对象Server.java\n1234567891011121314151617181920package org.btr.ygo.web.config;import io.vertx.core.json.JsonObject;import lombok.AccessLevel;import lombok.Data;import lombok.experimental.Accessors;import lombok.experimental.FieldDefaults;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Data@Accessors(chain = true)@FieldDefaults(level = AccessLevel.PRIVATE)public class Server &#123;  // HttpServerOptions NetServerOptions  JsonObject options;  String type;  String name;&#125;\n\n配置读取ServerConfig.java\n123456789101112131415161718192021222324252627282930313233343536373839package org.btr.ygo.web.config;import io.vertx.core.json.JsonArray;import io.vertx.core.json.JsonObject;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.config.IConfig;import org.btr.ygo.core.config.YgoConfig;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Trunk;import java.util.HashMap;import java.util.Map;/** * 从配置文件中读取Web服务配置 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class ServerConfig implements IConfig&lt;Map&lt;Integer, Server&gt;&gt; &#123;  @Override  public Map&lt;Integer, Server&gt; read() &#123;    val config = Trunk.&lt;YgoConfig&gt;singleton(YgoConfig.class).read();    return read(config.getJsonObject(Const.VERTX).getJsonArray(Const.SERVER));  &#125;  // 根据端口分组  private Map&lt;Integer, Server&gt; read(JsonArray xs) &#123;    val map = new HashMap&lt;Integer, Server&gt;();    xs.forEach(d -&gt; &#123;      val json = JsonObject.mapFrom(d);      val options = json.getJsonObject(Const.OPTIONS);      val port = options.getInteger(Const.PORT, 8080);      val value = new Server().setName(json.getString(&quot;name&quot;)).setType(json.getString(&quot;type&quot;))        .setOptions(options);      map.put(port, value);    &#125;);    return map;  &#125;&#125;\n\n配置示例application.yaml\n1234567891011121314#### 配置示例ygo:  profile: default  vertx:    name: vertx-ygo    options:      haEnabled: false      preferNativeTransport: true    server:      - name: default-port        type: http        options:          host: 0.0.0.0          port: 8080\n\nhttp本体EventloopHttpActor.java\n123456789101112131415161718192021222324252627282930313233343536373839package org.btr.ygo.web.actor;import io.vertx.core.AbstractVerticle;import io.vertx.core.http.HttpServerOptions;import io.vertx.ext.web.Router;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Eventloop;import org.btr.ygo.core.constant.Const;import org.btr.ygo.web.config.Server;import org.btr.ygo.web.constant.Console;import org.btr.ygo.web.kit.Deck;import org.btr.ygo.web.kit.Network;/** * eventloop的http实现 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@Eventlooppublic final class EventloopHttpActor extends AbstractVerticle &#123;  @Override  public void start() throws Exception &#123;    // http服务集合    Deck.HTTP_SERVERS.forEach((port, config) -&gt; &#123;      // 获取路由      val router = Router.router(vertx);      server(router, port, config);    &#125;);  &#125;  // 发布http服务  private void server(Router router, Integer port, Server config) &#123;    val options = new HttpServerOptions(config.getOptions());    vertx.createHttpServer(options).requestHandler(router).listen();    // 发布api地址    val path = &quot;http://&quot; + Network.getIPv4() + Const.COLON + port + Const.SLASH;    log.info(Console.SERVER, getClass().getSimpleName(), Const.HTTP, path);  &#125;&#125;\n\n\nWorker集成本体这一块同Eventloop部分,不多赘述.\nWorkerExtractor.java\n1234567891011121314151617181920212223242526272829303132333435363738package org.btr.ygo.core.actor;import io.vertx.core.DeploymentOptions;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Worker;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Fn;import java.util.HashMap;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class WorkerExtractor implements IExtractor &#123;  private static final Map&lt;Class&lt;?&gt;, DeploymentOptions&gt; OPTIONS = new HashMap&lt;&gt;();  @Override  public DeploymentOptions extract(Class&lt;?&gt; cls) &#123;    log.info(Console.DEPLOY, Const.WORKER, cls.getName());    return Fn.pool(OPTIONS, cls, () -&gt; extractValue(cls));  &#125;  private DeploymentOptions extractValue(Class&lt;?&gt; cls) &#123;    val anno = cls.getAnnotation(Worker.class);    val options =      new DeploymentOptions().setHa(anno.ha()).setInstances(anno.instances()).setWorker(true);    if (!OPTIONS.isEmpty()) &#123;      val latest = OPTIONS.getOrDefault(cls, new DeploymentOptions());      val oldest = options.toJson();      oldest.mergeIn(latest.toJson(), true);      return new DeploymentOptions(oldest);    &#125;    log.info(Console.DEPLOYED, Const.WORKER, options.getInstances(), options.isHa(), options.toJson());    return options;  &#125;&#125;\n\nWorkerActor.java\n12345678910111213141516171819202122package org.btr.ygo.core.actor;import io.vertx.core.Vertx;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Trunk;import org.btr.ygo.core.kit.Verticles;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class WorkerActor implements IActor&#123;  @Override  public void integration(Vertx vertx) &#123;    val extractor = Trunk.&lt;WorkerExtractor&gt;singleton(WorkerExtractor.class);    Trunk.WORKERS.forEach(cls -&gt; Verticles.deploy(vertx, extractor.extract(cls), cls));    Runtime.getRuntime().addShutdownHook(      new Thread(() -&gt; Trunk.WORKERS.forEach(cls -&gt; Verticles.undeploy(vertx, cls, Const.WORKER))));  &#125;&#125;\n\nhttp实现http的请求调度eventloop已经实现,这里我们只需要实现http的请求处理.\nhttp本体WorkerHttpActor.java\n123456789101112131415161718192021222324252627package org.btr.ygo.web.actor;import io.vertx.core.AbstractVerticle;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.actor.IReplier;import org.btr.ygo.core.annotations.Worker;import org.btr.ygo.core.kit.Trunk;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@Workerpublic final class WorkerHttpActor extends AbstractVerticle &#123;  @Override  public void start() throws Exception &#123;    // 所有的Vert.x消息    Trunk.RECEIPTS.forEach(data -&gt; &#123;      val method = data.getMethod();      // 根据返回值类型,Future Object决定应答模式.      val replier = IReplier.get(method.getReturnType());      // Vert.x EventBus上根据地址开始消费消息并响应.      vertx.eventBus().consumer(data.getAddr(), msg -&gt; replier.reply(data.getProxy(), method, msg));    &#125;);  &#125;&#125;\n\n\n总结这一章我们大体上实现了Eventloop、Worker类、配置与Vert.x的集成,让这些玩意转成Vert.x能看懂的Verticle.\n","slug":"从零开始撸框架(5)-与Vert.x集成 基础篇(一)","date":"2021-05-07T00:27:12.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java,代理模式","author_index":"因雨而生"},{"id":"45dcae5ccfe9e8f63cc7cbe584bb9d7a","title":"从零开始撸框架(4)-配置读取器","content":"到目前为止,框架已经支持了 工厂 、 Bean分组 、 依赖注入 ,这一章我们来实现框架配置的读取.\n配置读取基类老样子,我们还是先定义一个读取基类,方便后续子类扩展.\nIConfig.java\n123456789package org.btr.ygo.core.config;/** * 读取配置文件 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IConfig&lt;T&gt; &#123;  T read();&#125;\n\n辅助类配置加载肯定会涉及到IO流IO.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.btr.ygo.core.kit;import lombok.extern.log4j.Log4j2;import lombok.val;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.net.JarURLConnection;import java.net.URL;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class IO &#123;  // 确保能获取输入流  public static InputStream ensureRead(String filename) &#123;    return Fn.ensureRun(() -&gt; &#123;      val file = new File(filename);      var in = Fn.ensureRun(file.exists() &amp;&amp; file.isFile(),        // 1. 直接读文件        () -&gt; new FileInputStream(file),        // 2. 环境上下文        () -&gt; Thread.currentThread().getContextClassLoader().getResourceAsStream(filename));      // 3. 当前类加载器      if (Objects.isNull(in)) in = IO.class.getResourceAsStream(filename);      // 4. 类加载器      if (Objects.isNull(in)) in = ClassLoader.getSystemResourceAsStream(filename);      // 5. jar加载      if (Objects.isNull(in) &amp;&amp; filename.contains(&quot;jar!/&quot;)) &#123;        val url = new URL(filename);        val protocol = url.getProtocol();        if (&quot;jar&quot;.equals(protocol)) &#123;          val jar = (JarURLConnection) url.openConnection();          in = jar.getInputStream();        &#125;      &#125;      if (Objects.isNull(in)) throw new IllegalStateException(filename);      return in;    &#125;, filename);  &#125;&#125;\n\n加载基类,子类继承后实现多种不同的加载方式,比如: yaml 、 xml 、properties 、 json .ILoader.java\n1234567891011121314package org.btr.ygo.core.config;import org.btr.ygo.core.kit.Trunk;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface ILoader &#123;  // 这里根据后缀名调用对应的loader.  Map&lt;String, ILoader&gt; MAP = Map.of(&quot;.yaml&quot;, Trunk.singleton(YamlLoader.class));  String load(String filename);&#125;\n\n这里我只实现yaml读取,其他省略.\ncore模块build.gradle追加\n1234dependencies &#123;  // 读yaml  compile &quot;com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:$jacksonVersion&quot;&#125;\nYamlLoader.java\n1234567891011121314151617package org.btr.ygo.core.config;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;import org.btr.ygo.core.kit.Fn;import org.btr.ygo.core.kit.IO;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class YamlLoader implements ILoader &#123;  private static final ObjectMapper YAML = new YAMLMapper();  @Override  public String load(String filename) &#123;    return Fn.ensureRun(() -&gt; YAML.readTree(IO.ensureRead(filename)).toString(), filename);  &#125;&#125;\n\n\nConfigs.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.btr.ygo.core.kit;import io.netty.util.internal.StringUtil;import io.vertx.core.json.JsonObject;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.config.ILoader;import org.btr.ygo.core.constant.Console;import java.util.HashMap;import java.util.Map;import java.util.Objects;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class Configs &#123;  private static final Map&lt;String, JsonObject&gt; CONFIG = new HashMap&lt;&gt;();  // 框架配置文件名,我这里写死了yaml  private static final String CONFIG_FILE = &quot;application.yaml&quot;;  // 框架默认配置  private static final String DEFAULT = &quot;ygo/&quot;;  // 默认采用的loader,这里我写死了yaml,可自行扩展成动态.  private static final ILoader LOADER = ILoader.MAP.get(&quot;.yaml&quot;);  // 生成读取文件名  // 1. application.yaml  // 2. application-key.yaml  public static String generateFilename(String key) &#123;    return Fn.ensureRun(Objects.isNull(key),      () -&gt; CONFIG_FILE,      () -&gt; &quot;application-&quot; + key + &quot;.yaml&quot;);  &#125;  public static JsonObject read(String filename) &#123;    val name = generateFilename(filename);    val value = CONFIG.get(name);    // 缓存有则不再走io流读取    if (Objects.nonNull(value)) return value;    val merged = new JsonObject();    // 1.默认配置    val defaultPath = DEFAULT + name;    val silent = loader(defaultPath);    log.info(Console.CONFIG_READ, &quot;Default&quot;, defaultPath);    merged.mergeIn(silent, true);    // 2.用户自定义配置    log.info(Console.CONFIG_READ, &quot;User&quot;, name);    val custom = loader(name);    // 两者配置都存在的场合需要合并    if (!custom.isEmpty()) &#123;      log.info(Console.MERGE);      merged.mergeIn(custom, true);    &#125;    CONFIG.put(name, merged);    return merged;  &#125;  // 所有loader加载完后统一转换成Vert.x的JsonObject格式数据.  private static JsonObject loader(String filename) &#123;    val text = LOADER.load(filename);    return Fn      .ensureRun(StringUtil.isNullOrEmpty(text), JsonObject::new, () -&gt; new JsonObject(text));  &#125;&#125;\n\n\n框架配置读取器本体整个框架的配置YgoConfig.java\n12345678910111213141516171819package org.btr.ygo.core.config;import io.vertx.core.json.JsonObject;import lombok.val;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Configs;/** * 框架整体配置 * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class YgoConfig implements IConfig&lt;JsonObject&gt; &#123;  @Override  public JsonObject read() &#123;    // 读取application.yaml    val json = Configs.read(null);    return json.getJsonObject(Const.YGO);  &#125;&#125;\n\n测试在 &#x2F;test&#x2F;main&#x2F;resources 、 &#x2F;test&#x2F;main&#x2F;resources&#x2F;ygo&#x2F; 目录下分别添加 application.yaml 文件.application.yaml\n123ygo:  name: test  profile: default\n\n配置读取测试类IConfigTest.java\n12345678910111213141516171819package org.btr.ygo.core.config;import lombok.val;import org.btr.ygo.core.kit.Trunk;import org.junit.Assert;import org.junit.Test;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public class IConfigTest &#123;  @Test  public void testYgo() &#123;    val config = Trunk.&lt;YgoConfig&gt;singleton(YgoConfig.class);    val json = config.read();    val data = json.getString(&quot;name&quot;);    Assert.assertEquals(data, &quot;test&quot;);  &#125;&#125;\n\n测试结果Vert.x配置读取器本体VertxConfig.java\n12345678910111213141516171819202122232425package org.btr.ygo.core.config;import io.vertx.core.VertxOptions;import lombok.val;import org.btr.ygo.core.constant.Const;import org.btr.ygo.core.kit.Trunk;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public class VertxConfig implements IConfig&lt;VertxOptions&gt; &#123;  @Override  public VertxOptions read() &#123;    // 先读取框架配置    val ygo = Trunk.&lt;YgoConfig&gt;singleton(YgoConfig.class);    val config = ygo.read();    // 从框架配置中读取Vertx部分    val options =  new VertxOptions(config.getJsonObject(Const.VERTX).getJsonObject(Const.OPTIONS));    // 这里是我个人习惯,将线程数设置为CPU核心*2    // 可以参考这个 https://www.cnblogs.com/dennyzhangdd/p/6909771.html    // 工作线程默认为20,如果没变动则将其改为CPU核数*2;    if (20 == options.getWorkerPoolSize()) options.setWorkerPoolSize(VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE);    return options;  &#125;&#125;\n\n测试test 文件夹下的 application.yaml 追加内容\n12345678ygo:  name: test  profile: default  vertx:    name: vertx-ygo    options:      haEnabled: false      preferNativeTransport: true\n\nIConfigTest.java追加测试\n123456789public class IConfigTest &#123;  ...  @Test  public void testVertx() &#123;    val config = Trunk.&lt;VertxConfig&gt;singleton(VertxConfig.class);    val options = config.read();    Assert.assertTrue(options.getPreferNativeTransport());  &#125;&#125;\n\n测试结果\n\n总结这一章我们实现了框架配置的yaml读取,并且也留下了修改的入口,日后扩展其他方式也无须修改源代码,子类自行实现 ILoader.java 即可.\n框架的其他参数读取同理,扩展 IConfig.java 即可.\n","slug":"从零开始撸框架(4)-配置读取器","date":"2021-05-01T22:43:37.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"bf9123d57d7a0fda9f11ed154298fba1","title":"从零开始撸框架(3)-类扫描器","content":"上一章我们已经把每个包中的类都统一加载到一个Set中了,以后凡是需要用到类的场景我们都可以从Set集合中取出,但是光这样还不够好.往后所有操作都依赖于这一个集合,这也意味着我们对集合元素有改动都会影响到所有组件使用.所以这一章我们来进一步细化,根据不同的需求把这个大Set集合拆分成小的集合.\n扫描基类这里我们定义一个扫描接口,接收类集合得出我们想要的结果,方便子类根据不同需求进行扩展.\nIScanner.java\n12345678910package org.btr.ygo.core.scan;import java.util.Set;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public interface IScanner&lt;T&gt; &#123;  T scan(Set&lt;Class&lt;?&gt;&gt; classes);&#125;\n\n下面根据需求实现不同的子类,这里采用的是Reactor架构模型.\n\n事件循环线程(Eventloop)扫描器首先我们把所有事件循环的类从Set集合中独立出来,这块是框架调度分发的核心,完全有独立出来的意义.\n辅助类这里定义几种类型,分别对应http、tcp、sock服务.EventloopType.java\n12345678910111213141516171819package org.btr.ygo.constant;import java.util.Arrays;import java.util.List;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public enum EventloopType &#123;  HTTP, TCP, SOCK;  private static final List&lt;String&gt; HTTP_TYPE =    Arrays.asList(HTTP.name().toLowerCase(), SOCK.name().toLowerCase());  public static boolean isHttp(String type) &#123;    return HTTP_TYPE.contains(type);  &#125;  public static boolean isNet(String type) &#123;    return TCP.name().equalsIgnoreCase(type);  &#125;&#125;\n注解式开发,用注解把类标识出来.Eventloop.java\n1234567891011121314151617181920212223package org.btr.ygo.annotations;import org.btr.ygo.constant.EventloopType;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)public @interface Eventloop &#123;  boolean ha() default false;  int instances() default 1;  EventloopType type() default EventloopType.HTTP;&#125;\n\n本体具体的事件循环扫描实现,通过扫描包含@Eventloop注解的类.\nEventloopScanner.java1234567891011121314151617181920212223package org.btr.ygo.core.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Eventloop;import org.btr.ygo.core.constant.Console;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class EventloopScanner implements IScanner&lt;Set&lt;Class&lt;?&gt;&gt;&gt; &#123;  @Override  public Set&lt;Class&lt;?&gt;&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    val ret =      classes.stream().filter(d -&gt; d.isAnnotationPresent(Eventloop.class)).collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;Eventloop&quot;, ret.size());    return ret;  &#125;&#125;### 测试IScannerTest.java123456789101112131415161718192021222324252627package org.btr.ygo.core.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Eventloop;import org.btr.ygo.core.kit.Packages;import org.btr.ygo.core.kit.Trunk;import org.hamcrest.CoreMatchers;import org.junit.Assert;import org.junit.Test;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public class IScannerTest &#123;  @Eventloop  public static class TestEventloop &#123;  &#125;  @Test  public void testEventloop() &#123;    val classes = Packages.scan();    val scanner = Trunk.&lt;EventloopScanner&gt;singleton(EventloopScanner.class);    val ret = scanner.scan(classes);    Assert.assertThat(ret, CoreMatchers.hasItem(TestEventloop.class));  &#125;&#125;测试结果工作线程(Worker)扫描器工作类负责框架各种任务的执行,具体实现同Eventloop.\n辅助类Worker.java\n1234567891011121314151617181920package org.btr.ygo.core.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Worker &#123;  boolean ha() default false;  int instances() default 1;&#125;\n\n本体WorkerScanner.java1234567891011121314151617181920212223package org.btr.ygo.core.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Worker;import org.btr.ygo.core.constant.Console;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class WorkerScanner implements IScanner&lt;Set&lt;Class&lt;?&gt;&gt;&gt; &#123;  @Override  public Set&lt;Class&lt;?&gt;&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    val ret =      classes.stream().filter(d -&gt; d.isAnnotationPresent(Worker.class)).collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;Worker&quot;, ret.size());    return ret;  &#125;&#125;### 测试在IScannerTest.java中追加一例测试.12345678910111213public class IScannerTest &#123;  ...  @Worker  public static class TestWorker &#123;  &#125;  @Test  public void testWorker() &#123;    val classes = Packages.scan();    val scanner = Trunk.&lt;WorkerScanner&gt;singleton(WorkerScanner.class);    val ret = scanner.scan(classes);    Assert.assertThat(ret, CoreMatchers.hasItem(TestWorker.class));  &#125;&#125;测试结果Vert.x消息扫描器在Vert.x官网示例中,我们可以看到它Eventloop与Worker交互是通过vertx.eventBus()来实现的.因此我们把交互消息也定义成一个类,把它也从类集合中独立出来.\n辅助类Receipt.java\n1234567891011121314151617181920212223package org.btr.ygo.core.scan;import lombok.AccessLevel;import lombok.Data;import lombok.experimental.Accessors;import lombok.experimental.FieldDefaults;import java.lang.reflect.Method;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Data@Accessors(chain = true)@FieldDefaults(level = AccessLevel.PRIVATE)public class Receipt &#123;  // 承载消息的类.  Object proxy;  // 发布在Vert.x上的消息地址.  String addr;  // 具体执行的方法.  Method method;&#125;\n分别定义EventBus和Addr两个注解,用来标识类是否要处于Vert.x的消息队列中和类在队列上的地址.EventBus.java\n123456789101112131415161718package org.btr.ygo.core.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)public @interface EventBus &#123;&#125;\nAddr.java\n12345678910111213141516171819package org.btr.ygo.core.annotations;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD,ElementType.ANNOTATION_TYPE&#125;)public @interface Addr &#123;  String value();&#125;\n\n我们在之前的Trunk.java工厂类中添加新的方法,分别实现获取实现类和代理类的功能.Trunk.java\n123456789101112131415161718192021222324public final class Trunk &#123;  ...  public static Class&lt;?&gt; getImpl(Class&lt;?&gt; cls) &#123;    return Fn.ensureRun(() -&gt; &#123;      // 搜索全部包下的类得到所有cls实现的类,必须是单实现.      val classes = Packages.scan().stream()        // 过滤掉自身以及子类        .filter(d -&gt; cls.isAssignableFrom(d) &amp;&amp; d != cls)        .collect(Collectors.toList());      return 1 == classes.size() ? classes.get(0) : null;    &#125;, cls);  &#125;  public static Object getProxy(Class&lt;?&gt; cls) &#123;    return Fn.ensureRun(!cls.isInterface(),      // 非接口直接单例对象      () -&gt; Trunk.singleton(cls),      () -&gt; &#123;        // 接口获取其实现类        val implCls = Trunk.getImpl(cls);        // 实现类不为空获取其单例对象        return Fn.ensureRun(() -&gt; Trunk.singleton(implCls), implCls);      &#125;);  &#125;&#125;\n\n本体ReceiptScanner.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243package org.btr.ygo.core.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.annotations.Addr;import org.btr.ygo.core.annotations.EventBus;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.kit.Methods;import org.btr.ygo.core.kit.Trunk;import java.lang.reflect.Method;import java.util.Arrays;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class ReceiptScanner implements IScanner&lt;Set&lt;Receipt&gt;&gt; &#123;  @Override  public Set&lt;Receipt&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    // 所有@EventBus注解的类    val eventBuses = classes.stream().filter(d -&gt; d.isAnnotationPresent(EventBus.class))      .collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;EventBus&quot;, eventBuses.size());    val receipts = eventBuses.stream()      // 根据类下所有的方法,将其转成为Receipt对象.      .flatMap(d -&gt; Arrays.stream(d.getDeclaredMethods()).filter(Methods::validateMethod))      .map(this::scan).collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;Address&quot;, receipts.size());    return receipts;  &#125;  private Receipt scan(Method method) &#123;    val cls = method.getDeclaringClass();    val proxy = Trunk.getProxy(cls);    val addr = method.getAnnotation(Addr.class).value();    val data = new Receipt().setAddr(addr).setMethod(method)      .setProxy(proxy);    log.info(&quot;Address: &#123;&#125;&quot;, addr);    return data;  &#125;&#125;\n测试继续在IScannerTest.java追加测试\n123456789101112131415161718public class IScannerTest &#123;  ...  @EventBus  public static class TestEventBus &#123;    @Addr(&quot;test&quot;)    public void test() &#123;    &#125;  &#125;  @Test  public void testReceipt() &#123;    val classes = Packages.scan();    val scanner = Trunk.&lt;ReceiptScanner&gt;singleton(ReceiptScanner.class);    val data = new Receipt().setAddr(&quot;test&quot;);    val xs = scanner.scan(classes);    val ret = xs.stream().filter(d -&gt; data.getAddr().equals(d.getAddr())).findAny();    Assert.assertTrue(ret.isPresent());  &#125;&#125;\n测试结果\n\n依赖注入(Dependency Injection)扫描器用过spring的都知道 @Resource 、 @Autowire 注入,其中前者是jsr250的,后者是spring封装的.\n这里我们也可以封装一套类似于Spring的,也可以基于现有的注解开发,在这我选择基于jsr330注解开发.\n在core模块build.gradle中追加\n123456dependencies &#123;  ...  // jsr330  compile &quot;javax.inject:javax.inject:1&quot;  ...&#125;\n\n辅助类在Trunk.java追加一个新的方法\n12345678910public final class Trunk &#123;  ...  // 递归查询是否有实现类  public static boolean hasMatchImpl(Class&lt;?&gt; cls, Class&lt;?&gt; interfaceCls) &#123;    var b = Arrays.asList(cls.getInterfaces()).contains(interfaceCls);    if (!b &amp;&amp; Objects.nonNull(cls.getSuperclass()))      b = hasMatchImpl(cls.getSuperclass(), interfaceCls);    return b;  &#125;&#125;\n\n这里和Package扫描一样,类比较多,我们一个类创建一个线程来加快注入的扫描.DiThread.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package org.btr.ygo.core.scan;import io.netty.util.internal.StringUtil;import lombok.AccessLevel;import lombok.experimental.FieldDefaults;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import org.btr.ygo.core.kit.Trunk;import javax.inject.Inject;import javax.inject.Named;import java.lang.reflect.Field;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import java.util.function.Supplier;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@FieldDefaults(level = AccessLevel.PUBLIC, makeFinal = true)public final class DiThread extends Thread &#123;  // 当前类  Class&lt;?&gt; cls;  // 所有类,需要在这里面找到当前类所有字段类型实现来注入.  Set&lt;Class&lt;?&gt;&gt; classes;  // 当前类所有字段的对应类型  Map&lt;String, Class&lt;?&gt;&gt; FIELD_INJECTS = new HashMap&lt;&gt;();  public DiThread(Class&lt;?&gt; cls, Set&lt;Class&lt;?&gt;&gt; classes) &#123;    setName(&quot;ygo-di-scanner-&quot; + getId());    this.cls = cls;    this.classes = classes;  &#125;  @Override  public void run() &#123;    // 类转换成类字段数组    val fields = Arrays.stream(cls.getDeclaredFields())      // 过滤掉没有@Inject注解的字段      .filter(field -&gt; field.isAnnotationPresent(Inject.class))      // 转成 key -&gt; 类字段名 value -&gt; 字段类型的map格式       .collect((Supplier&lt;HashMap&lt;String, Class&lt;?&gt;&gt;&gt;) HashMap::new,        (map, field) -&gt; map.put(field.getName(), standard(field)), HashMap::putAll);    FIELD_INJECTS.putAll(fields);  &#125;  // 标准注入  private Class&lt;?&gt; standard(Field field) &#123;    val type = field.getType();    if (!type.isInterface()) return type;    val name = field.getName();    // 字段的实现列表    val impls =      classes.stream().filter(cls -&gt; Trunk.hasMatchImpl(cls, type)).collect(Collectors.toList());    // 空实现    if (impls.isEmpty()) &#123;      val typeName = field.getDeclaringClass().getName();      log.error(Console.JSR330, typeName, name, type.getName());      throw new IllegalArgumentException();    &#125;    else &#123;      val size = impls.size();      // 多实现      if (1 != size) return qualifier(field, impls);        // 只有一个实现      else &#123;        val implCls = impls.get(0);        log.info(Console.DI, cls, name, implCls.getName(), Inject.class);        return implCls;      &#125;    &#125;  &#125;  // 多实现,通过value指定实例.  private Class&lt;?&gt; qualifier(Field field, List&lt;Class&lt;?&gt;&gt; implClasses) &#123;    val names = implClasses.stream().map(Class::getName).collect(Collectors.toList());    log.info(Console.SCANNED, &quot;Instance&quot;, String.join(&quot;,&quot;, names));    val qualifier = field.getAnnotation(Named.class).value();    val cls = implClasses.stream()      .filter(item -&gt; &#123;        val named = item.getAnnotation(Named.class).value();        return qualifier.equals(named) &amp;&amp; !StringUtil.isNullOrEmpty(named);      &#125;).findAny();    return cls.get();  &#125;&#125;\n\n本体DiScanner.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.btr.ygo.core.scan;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import javax.inject.Inject;import java.util.Arrays;import java.util.HashMap;import java.util.Map;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class DiScanner implements IScanner&lt;Map&lt;Class&lt;?&gt;, Map&lt;String, Class&lt;?&gt;&gt;&gt;&gt; &#123;  @Override  public Map&lt;Class&lt;?&gt;, Map&lt;String, Class&lt;?&gt;&gt;&gt; scan(Set&lt;Class&lt;?&gt;&gt; classes) &#123;    // 所有包含@Inject注解字段的类    val xs = classes.stream().filter(cls -&gt; Arrays.stream(cls.getDeclaredFields())      .anyMatch(field -&gt; field.isAnnotationPresent(Inject.class)))      .collect(Collectors.toSet());    // 一个类一个线程    val threads = xs.stream().map(cls -&gt; new DiThread(cls, classes))      .collect(Collectors.toSet());    // 线程启动    threads.forEach(Thread::start);    // 最终返回数据结构 key -&gt; 类类型, value -&gt; (key -&gt; 字段名, value -&gt; 字段类型).    val ret = new HashMap&lt;Class&lt;?&gt;, Map&lt;String, Class&lt;?&gt;&gt;&gt;();    try &#123;      // 主线程等待子线程全部扫描完毕      for (DiThread thread : threads) thread.join();      for (DiThread thread : threads) &#123;        val key = thread.cls;        val value = thread.FIELD_INJECTS;        ret.put(key, value);        log.info(Console.INJECT, key.getName(), value.size());      &#125;    &#125; catch (Exception ex) &#123;      ex.printStackTrace();    &#125;    return ret;  &#125;&#125;\n\n测试IScannerTest.java追加\n123456789101112131415161718192021222324252627public class IScannerTest &#123;  ...  public interface TestQualifier &#123;&#125;  @Named(&quot;testQualifierA&quot;)  public static class TestQualifierA implements TestQualifier &#123;&#125;  @Named(&quot;testQualifierB&quot;)  public static class TestQualifierB implements TestQualifier &#123;&#125;  public static class TestDi &#123;    @Inject    private TestEventBus testEventBus;    @Inject    @Named(&quot;testQualifierB&quot;)    private TestQualifier testQualifier;  &#125;  @Test  public void testDi() &#123;    val classes = Packages.scan();    val scanner = Trunk.&lt;DiScanner&gt;singleton(DiScanner.class);    val ret = scanner.scan(classes);    val data = ret.get(TestDi.class);    val type1 = data.get(&quot;testEventBus&quot;);    Assert.assertEquals(type1, TestEventBus.class);    val type2 = data.get(&quot;testQualifier&quot;);    Assert.assertNotEquals(type2, TestQualifierA.class);    Assert.assertEquals(type2, TestQualifierB.class);  &#125;&#125;\n测试结果\n\n总结这一章我们基于一个扫描基类实现了各个核心组件的解耦扫描,以后有新的组件只需要自行扩展实现IScanner.java即可.\n在往后几章我们肯定还会基于这个基类继续扩展功能实现.\n","slug":"从零开始撸框架(3)-类扫描器","date":"2021-05-01T16:01:49.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"1f961444d2b8322d4f975faeb98fbea1","title":"从零开始撸框架(2)-项目龙骨","content":"项目结构上文说到框架包含Ioc、Di、Orm、Cache等功能,其中只有前两者为核心功能.那么结构上可以采用分包结构开发,即分为核心、组件等功能包,如下.\n\norg.btr.ygo.core 核心包,包含了框架ioc、di功能,为其他组件提供支持.\norg.btr.ygo.tp tp意为(third-party),可以将数据库、缓存等需要引入第三方jar的功能放到这.\norg.btr.ygo.web web功能\n\n接下来我们先完成core核心包的功能开发.\n\n工厂说到核心Ioc、Di自然离不开工厂模式.我们先准备写工厂会用到的jar\nbuild.gradle\n123456dependencies &#123;  // 高性能反射  compile &quot;com.esotericsoftware:reflectasm:1.11.9&quot;  // vertx核心jar  compile &quot;io.vertx:vertx-core:$vertxVersion&quot;&#125;\n\n辅助类类工厂会经常用到反射,我们需要写几个类来辅助工厂实现.\n函数类,这里会存放以后会用到的各种函数式方法.EnsureSuppliver.java\n1234567891011package org.btr.ygo.core.funtions;/** * java8的异常版本 * @see java.util.function.Supplier * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@FunctionalInterfacepublic interface EnsureSuppliver&lt;T&gt; &#123;  T get() throws Exception;&#125;\nEnsureExec.java\n1234567891011package org.btr.ygo.core.funtions;/** * java8的异常版本 * @see java.util.function.Consumer * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@FunctionalInterfacepublic interface EnsureExec &#123;  void exec() throws Exception;&#125;\nFn.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.btr.ygo.core.kit;import lombok.extern.log4j.Log4j2;import org.btr.ygo.core.funtions.EnsureExec;import org.btr.ygo.core.funtions.EnsureSuppliver;import java.util.Arrays;import java.util.Map;import java.util.Objects;import java.util.function.Supplier;/** * 函数类,封装了条件分支以及非空判断. * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class Fn &#123;  // 连接池函数,优先使用key在池中找可用value,找不到才会通过Supplier去创建一个value.  public static &lt;K, V&gt; V pool(Map&lt;K, V&gt; map, K key, Supplier&lt;V&gt; fn) &#123;    V value = map.get(key);    if (Objects.isNull(value)) &#123;      value = fn.get();      map.put(key, value);    &#125;    return value;  &#125;  public static &lt;T&gt; T ensureRun(EnsureSuppliver&lt;T&gt; fn, Object... args) &#123;    return ensureRun(null, fn, args);  &#125;  public static &lt;T&gt; T ensureRun(T defaultValue, EnsureSuppliver&lt;T&gt; fn, Object... args) &#123;    T ret = null;    try &#123;      if (Arrays.stream(args).allMatch(Objects::nonNull)) ret = fn.get();    &#125; catch (Exception e) &#123;      e.printStackTrace();    &#125; finally &#123;      if (Objects.isNull(ret)) ret = defaultValue;    &#125;    return ret;  &#125;  public static &lt;T&gt; T ensureRun(boolean condition, EnsureSuppliver&lt;T&gt; fn1, EnsureSuppliver&lt;T&gt; fn2) &#123;    T ret = null;    try &#123;      if (condition &amp;&amp; Objects.nonNull(fn1)) ret = fn1.get();      else if (!condition &amp;&amp; Objects.nonNull(fn2)) ret = fn2.get();    &#125; catch (Exception e) &#123;      e.printStackTrace();    &#125;    return ret;  &#125;  public static void ensureExec(EnsureExec fn, Object... args) &#123;    try &#123;      if (Arrays.stream(args).allMatch(Objects::nonNull)) fn.exec();    &#125; catch (Exception ex) &#123;      ex.printStackTrace();    &#125;  &#125;  public static void ensureExec(boolean condition, EnsureExec fn1) &#123;    ensureExec(condition, fn1, null);  &#125;  public static void ensureExec(boolean condition, EnsureExec fn1, EnsureExec fn2) &#123;    try &#123;      if (condition &amp;&amp; Objects.nonNull(fn1)) fn1.exec();      else if (!condition &amp;&amp; Objects.nonNull(fn2)) fn2.exec();    &#125; catch (Exception ex) &#123;      ex.printStackTrace();    &#125;  &#125;  public static String join(CharSequence delimiter, Object... param) &#123;    return Fn.ensureRun(      () -&gt; Arrays.stream(param).map(Objects::toString).collect(Collectors.joining(delimiter)),      delimiter, param);  &#125;&#125;\n\n反射类,有关反射的方法都放在这.Reflect.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243package org.btr.ygo.core.kit;import com.esotericsoftware.reflectasm.ConstructorAccess;import lombok.extern.log4j.Log4j2;import lombok.val;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@SuppressWarnings(&quot;all&quot;)public final class Reflect &#123;  // reflectasm开销主要在于对象的获取,我们把它存起来.  private static final Map&lt;Class&lt;?&gt;, ConstructorAccess&gt; CONSTRUCTORS = new HashMap&lt;&gt;();  public static &lt;T&gt; T constructor(Class&lt;?&gt; cls, Object... args) &#123;    T ret = null;    try &#123;      val constructors = cls.getDeclaredConstructors();      // 拿到类的所有构造函数,我们根据参数来判断选用何种方式创建对象.      // 优先使用无参,这样能调用到reflectasm.      // 无参不满足就只能走Java原生了.      for (Constructor&lt;?&gt; constructor : constructors) &#123;        val size = args.length;        if (0 == size) ret = noArgConstructor(cls);        else if (size != constructor.getParameterTypes().length) continue;        ret = (T) constructor.newInstance(args);      &#125;      return ret;    &#125; catch (Exception e) &#123;      e.printStackTrace();      return ret;    &#125;  &#125;  // 这里用到了reflectasm高性能反射,缺点就是仅支持无参.  public static &lt;T&gt; T noArgConstructor(Class&lt;?&gt; cls) &#123;    val access = Fn.pool(CONSTRUCTORS, cls, () -&gt; ConstructorAccess.get(cls));    return (T) access.newInstance();  &#125;&#125;\n\n本体Trunk.java\n123456789101112131415161718192021222324252627package org.btr.ygo.core.kit;import lombok.extern.log4j.Log4j2;import java.util.HashMap;import java.util.Map;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2@SuppressWarnings(&quot;unchecked&quot;)public final class Trunk &#123;  // 单例存储所有类对象  private static final Map&lt;String, Object&gt; SINGLETON = new HashMap&lt;&gt;();  // 所有扫描的类  public static final Set&lt;Class&lt;?&gt;&gt; CLASSES = new HashSet&lt;&gt;();  // 单例,优先读map对象,无则懒加载获取实例并存入map.  public static &lt;T&gt; T singleton(Class&lt;?&gt; cls, Object... args) &#123;    return (T) Fn.pool(SINGLETON, cls.getName(), () -&gt; instance(cls, args));  &#125;  // 实例,每调用一次产生一例.  public static &lt;T&gt; T instance(Class&lt;?&gt; cls, Object... args) &#123;    return Fn      .ensureRun(0 == args.length, () -&gt; Reflect.noArgConstructor(cls), () -&gt; Reflect.constructor(cls, args));  &#125;&#125;\n\n测试TrunkTest.java\n12345678910111213141516171819202122232425262728package org.btr.ygo.core.kit;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.TestApi;import org.junit.Assert;import org.junit.Test;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public class TrunkTest &#123;  @Test  public void testInstance() &#123;    val i1 = Trunk.instance(TestApi.class);    val i2 = Trunk.instance(TestApi.class);    log.info(&quot;i1: &#123;&#125;, i2: &#123;&#125;&quot;, i1, i2);    Assert.assertNotEquals(i1, i2);  &#125;  @Test  public void testSingleton() &#123;    val i1 = Trunk.singleton(TestApi.class);    val i2 = Trunk.singleton(TestApi.class);    log.info(&quot;i1: &#123;&#125;, i2: &#123;&#125;&quot;, i1, i2);    Assert.assertEquals(i1, i2);  &#125;&#125;\n\n测试结果\n\n类扫描加载Bean管理工厂有了接下来我们来实现类的扫描加载.\n辅助类由于包比较多,我们可以一包一线程的方式进行扫描,加速类的扫描.PackageThread.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.btr.ygo.core.kit;import lombok.val;import java.io.File;import java.net.JarURLConnection;import java.net.URL;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.Objects;import java.util.Set;import java.util.function.Predicate;import java.util.stream.Collectors;/** * 包扫描线程,一包一线程. * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public final class PackageThread extends Thread &#123;  public final String name;  Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();  public PackageThread(String name) &#123;    setName(&quot;ygo-package-scanner-&quot; + getId());    this.name = name;  &#125;  @Override  public void run() &#123;    classes.addAll(getClasses(null, name));  &#125;  public Set&lt;Class&lt;?&gt;&gt; getClasses(Predicate&lt;Class&lt;?&gt;&gt; filter, String name) &#123;    val classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;();    boolean recursive = true;    // a.b.c -&gt; a/b/c    val pkgDir = name.replace(&#x27;.&#x27;, &#x27;/&#x27;);    Fn.ensureExec(() -&gt; &#123;      val dirs = Thread.currentThread().getContextClassLoader().getResources(pkgDir);      while (dirs.hasMoreElements()) &#123;        val url = dirs.nextElement();        val protocol = url.getProtocol();        if (&quot;file&quot;.equals(protocol)) &#123;          val path = URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8);          findAndAdd(pkgDir, path, classes);        &#125;        else if (&quot;jar&quot;.equals(protocol))          classes.addAll(getJarClasses(pkgDir, name, url, recursive));      &#125;    &#125;);    return null == filter ? classes : classes.stream().filter(filter).collect(Collectors.toSet());  &#125;  private Set&lt;Class&lt;?&gt;&gt; getJarClasses(String pkgDir, String name, URL url,    boolean recursive) &#123;    val classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;();    Fn.ensureRun(() -&gt; &#123;      // 去掉第一个.      var pkgPath = (name.startsWith(&quot;.&quot;)) ? name.substring(1) : name;      val jar = ((JarURLConnection) url.openConnection()).getJarFile();      val entries = jar.entries();      while (entries.hasMoreElements()) &#123;        val entry = entries.nextElement();        var entryName = entry.getName();        // 去掉第一个/        if (entryName.charAt(0) == &#x27;/&#x27;) entryName = entryName.substring(1);        if (entryName.startsWith(pkgDir)) &#123;          val idx = entryName.lastIndexOf(&#x27;/&#x27;);          // entryName存在/说明是package          // java/lang -&gt; java.lang          if (idx != -1) pkgPath = entryName.substring(0, idx).replace(&#x27;/&#x27;, &#x27;.&#x27;);          if ((idx != -1) || recursive) &#123;            // class文件            if (entryName.endsWith(&quot;.class&quot;) &amp;&amp; !entry.isDirectory()) &#123;              // 提取class文件名              val clsName =                entryName                  .substring(pkgPath.length() + 1, entryName.lastIndexOf(&quot;.class&quot;));              classes.add(Thread.currentThread().getContextClassLoader()                .loadClass(pkgPath + &#x27;.&#x27; + clsName));            &#125;          &#125;        &#125;      &#125;      return null;    &#125;, pkgDir, name, url);    return classes;  &#125;  private void findAndAdd(String pkgDir, String path, Set&lt;Class&lt;?&gt;&gt; classes) &#123;    Fn.ensureExec(() -&gt; &#123;      val file = new File(path);      if (!file.exists() || !file.isDirectory()) return;      val classFiles =        file.listFiles(pathname -&gt; (file.isDirectory()) || file.getName().endsWith(&quot;.class&quot;));      if (Objects.isNull(classFiles)) return;      // 去掉第一个.      val pkgPath = (pkgDir.startsWith(&quot;.&quot;)) ? pkgDir.substring(1) : pkgDir;      // 是否存在另一个文件夹      val processedName = pkgPath.replace(&#x27;/&#x27;, &#x27;.&#x27;);      for (File cls : classFiles) &#123;        // 目录直接跳过        if (cls.isDirectory())          findAndAdd(processedName + &#x27;.&#x27; + cls.getName(), cls.getAbsolutePath(),            classes);        else &#123;          val clsName = cls.getName();          val name = clsName.substring(0, clsName.lastIndexOf(&quot;.class&quot;));          classes.add(Thread.currentThread().getContextClassLoader()            .loadClass(processedName + &#x27;.&#x27; + name));        &#125;      &#125;    &#125;, pkgDir, path);  &#125;&#125;\n\n本体Packages.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package org.btr.ygo.core.kit;import lombok.extern.log4j.Log4j2;import lombok.val;import org.btr.ygo.core.constant.Console;import java.util.Arrays;import java.util.HashSet;import java.util.Set;import java.util.stream.Collectors;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */@Log4j2public final class Packages &#123;  // 忽略不扫描的包  private static final Set&lt;String&gt; IGNORE_PACKAGES = Set.of(    &quot;ch.qos.logback&quot;,    &quot;io.vertx.core&quot;,    &quot;io.netty&quot;,    &quot;com.fasterxml.jackson&quot;,    &quot;com.esotericsoftware&quot;,    &quot;java&quot;,    &quot;javax&quot;,    &quot;jdk&quot;,    &quot;sun&quot;,    &quot;groovy&quot;,    &quot;org.graalvm&quot;,    &quot;org.apache&quot;,    &quot;org.jboss&quot;,    &quot;com.sun&quot;,    &quot;org.slf4j&quot;,    &quot;org.yaml&quot;,    &quot;org.junit&quot;,    &quot;org.apache.logging.log4j&quot;  );  public static Set&lt;Class&lt;?&gt;&gt; scan() &#123;    if (Trunk.CLASSES.isEmpty()) &#123;      val classes = scan(getPackages().toArray(new String[]&#123;&#125;));      Trunk.CLASSES.addAll(classes);      log.info(Console.SCANNED, &quot;Class&quot;, classes.size());    &#125;    return Trunk.CLASSES;  &#125;  private static Set&lt;String&gt; getPackages() &#123;    val pkgs = Arrays.stream(Package.getPackages())      .map(Package::getName)      .filter(name -&gt; IGNORE_PACKAGES.stream().noneMatch(name::startsWith))      .collect(Collectors.toSet());    log.info(Console.SCANNED, &quot;Package&quot;, pkgs.size());    return pkgs;  &#125;  // 多线程扫描  private static HashSet&lt;Class&lt;?&gt;&gt; scan(String[] dirs) &#123;    val threads = Arrays.stream(dirs).map(PackageThread::new).collect(Collectors.toSet());    threads.forEach(Thread::start);    val ret = new HashSet&lt;Class&lt;?&gt;&gt;();    try &#123;      // 主线程等待子线程全部扫描完毕      for (PackageThread thread : threads) thread.join();      // 将所有线程值合并      for (PackageThread thread : threads) ret.addAll(thread.classes);    &#125; catch (Exception ex) &#123;      ex.printStackTrace();    &#125;    return ret;  &#125;&#125;\n\n测试PackageTest.java\n1234567891011121314151617package org.btr.ygo.core.kit;import lombok.val;import org.hamcrest.CoreMatchers;import org.junit.Assert;import org.junit.Test;/** * @author &lt;a href=&quot;mailto:1159930219@qq.com&quot;&gt;BornToRain&lt;/a&gt; */public class PackagesTest &#123;  @Test  public void test() &#123;    val classes = Packages.scan();    Assert.assertThat(classes, CoreMatchers.hasItem(Packages.class));  &#125;&#125;\n\n测试结果\n\n总结这一章我们完成了核心模块的龙骨搭建,让它拥有了两个最原始的功能,即工厂和类集合,有了这俩我们才能开发其他的组件.\n","slug":"从零开始撸框架(2)-项目龙骨","date":"2021-04-29T02:03:09.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"1da24bfae57d43586cc931d1d18b42d9","title":"奇淫巧技(2)-Jvm篇","content":"函数内联在讲函数内联之前还得讲一个Jvm经常遇到的异常StackOverFlowException,该异常一般翻译成堆栈溢出异常,其实正确或者说更严谨的翻译应该是栈溢出,栈溢出大部分发生在函数的循环或递归调用之中,极少数在对象循环创建中.\n函数调用过程\nJvm栈内存会存储所有热度函数以及它们本地变量和函数.\n新函数调用,新的栈帧加到了栈顶端,分配的本地变量和参数会存储在这.\n跳转到目标函数执行代码.\n函数返回,本地变量和参数都会销毁,栈顶被移除.\n返回原先地址继续执行.\n\n观察调用过程可以看到每次函数调用消耗都比较大,如果放在循环之中不停的重复压栈出栈操作就会导致栈溢出.\n如何优化1234// 1for (int i = 0; i &lt; list.size(); i++)// 2for (int i = 0,j = list.size(); i &lt; j; i++)\n\n\n方式1每次循环都会去调用list来获取他最新的size长度,上面我们已经说到了函数调用的开销,故而方式1会随着循环不断增加开销,此时函数的开销是N.\n方式2只在循环初始化的时候进行了一次函数调用获取size长度并用局部变量保存下来,后面循环开始之后再也没有函数调用开销,此时函数开销始终是1.\n\n如何避免或减少开销这时候就该聊到我们上面提到的函数内联了,它可以显著减少栈帧的创建,多个函数使用一个栈帧来避免栈帧过分.在Jvm中无法人为强行函数内联,只能建议.Jvm是通过函数字节大小以及热度来决定是否内联的,因为我们只要日常代码中满足以下条件即可.\n\n函数字节小于35字节时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxInlineSize&#x3D;N**来调整内联字节数\n当函数字节小于325字节并且函数是热点时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxFreqInlineSize&#x3D;N**来调整内联字节数\nJvm自动识别函数热度进行内联,我们也可以通过修改Jvm参数**-XX:CompileThreshold&#x3D;N**来调整函数热度\n这算是函数内联的隐含条件,编码中多多使用private、static、final来定义函数.如果一个函数没有被外部使用,用这些关键字可以建议Jvm进行内联.,Scala可以直接使用@inline注解来建议Jvm内联.\n\n","slug":"奇淫巧技(2)-Jvm篇","date":"2021-04-28T00:04:30.000Z","categories_index":"奇淫巧技","tags_index":"Jvm","author_index":"因雨而生"},{"id":"91972c9f8cfda280c91f3305c833ffbf","title":"奇淫巧技(1)-Java篇","content":"编码习惯多使用值(val)而不是变量(var)\n变量非线程安全,并发存在读写问题.而值因为其不可修改性天然线程安全无读写问题.多线程开发中值也不用锁,性能更优,程序猿也不用关心多线程下的并发读写锁问题,心智要求大大降低.\n单线程性能也更高,如图.123456789101112// 1public static int sum() &#123;  int a = 2;  int b = 3;  return a + b;&#125;// 2public static int sum() &#123;  val a = 2;  val b = 3;  return a + ｂ；&#125;\n方式１编译后123456789101112iconst_2// 设置a的值istore_0iconst_3// 设置b的值istore_1// 读取a的值iload_0// 读取b的值iload_1iaddireturn\n方式2编译后123// 常量折叠了,没有访问&quot;局部变量&quot;iconst_5ireturn\n不过有的场景下值与变量并无二异,比如将上图代码的常量值替换成动态计算的函数123456789101112// 1public static int sum() &#123;  int a = fun1();  int b = fun2();  return a + b;&#125;// 2public static int sum() &#123;  val a = fun1();  val b = fun2();  return a + b;&#125;\n编译后123456789101112invokestatic fun1:()I// 设置a的值istore_0invokestatic fun2:()I// 设置b的值istore_1// 读取a的值iload_0// 读取b的值iload_1iaddireturn\n\nswitch优化\n工具jarLombokLombok是一个简化Java代码的神兵利器,提供了很多非常实用的注解(并且是非运行时),能减少大量重复代码,其具体实现原理及机制在这不做展开,这里只讲应用.\n\n@Data 常用于开发中的Entity、VO、DTO上,会自动为其属性生成Getter、Setter函数,并覆盖实现了原生的ToString、HashCode、Equals函数.\n@Log4j2、Slf4j 为注解类生成一个日志静态量,名为log.\n@AllArgsConstructor 生成一个全参构造,一般配合构造注入使用.\n@Builder 设计模式中的建造者模式\n@Value 构建一个值对象,即类的属性都是不可变量.\n@Cleanup 自动为IO类型关闭资源.\nval Java9var的常量版本.ex: val i &#x3D; 1等效于final int i &#x3D; 1;.\n\nVavrVavr为Java提供了更为强大的Fp支持,虽然比不上其他Fp语言的简单明了,但在Java也算是首屈一指的函数式第三方jar了.\n\nOption(单个数据处理) 相比Optional更加完备\nTry(异常处理)\nValidation(数据校验)\nEither(异常处理)\nFuture(异步处理)\nTuple(元祖类型)\nLazy(惰性求值)\n\n每个函数更具体的信息官方文档都有详细介绍Vavr\n","slug":"奇淫巧技(1)-Java篇 ","date":"2021-04-27T23:20:29.000Z","categories_index":"奇淫巧技","tags_index":"Java,面向函数(FP)","author_index":"因雨而生"},{"id":"f1128ae1167b6a3027acc0aa9f078931","title":"从零开始撸框架(1)-写在开始之前","content":"起因码农日常搬砖中都听说过一句话: 不要重复造轮子(一说是不要造重复的轮子).与公司来说这句话自然是绝对正确的,自研或仿造的轮子往往各方面都不如开源现有的轮子来得好,这样对公司来说无疑是最致命的.但是与个人来说,造轮子的过程同时是阅读他人代码提升自己的过程,而且轮子造完自身也会有种莫名的满足感.\n随着开发的深入,项目需求越来越复杂.市面上一些开源轮子(Spring-boot,Vert.x,Akka)无法满足我们功能需求,自此日常开发中也会采用一些二次轮子(即基于开源轮子再封装一层, ex: Jeecg-boot, Di-boot…各种基于Spring-boot或封装或魔改的轮子).这类二次轮子中维护者或个人或公司,个人的全靠满腔热血,bug反馈以及后期升级堪忧.公司的往往包含多版本(民用、商用、企业)等并且收费不低.关于收费这事我个人看法就是不耻,诚然小部分公司都对这些开源轮子进行了大部分改动,但那总归只是少数.绝大部分都是给开源轮子封了一层皮就敢拿出来卖,这也是前阵子为啥Elastic修改开源协议这档子事.\n回到现在,既然市面上二次轮子也不少.我如今趁着三分钟热度也来造一个轮子未尝不可,只是这次我要和市面上常见的那些妖艳贱货不一样,绝对不会采用一些已经烂大街的技术或框架(当然这并不绝对).这次写下这一系列文章一方面给自己留档,一方面给以后那些想造轮子又找不到方法的朋友参考,这个小白兔有人替你们当了.\n定位所谓定位就是这框架目的是什么,起到什么作用,解决什么问题,适用什么场景,面向什么人员.个人认为对于项目刚启动时候的定位不一定就需要画类图写设计文档,毕竟最初只有雏形概念.我们完全可以把核心概念草稿下来就好,日后再补上类图设计文档也不是问题.\n我们这次框架目的就是造一个类似于Spring-boot的轮子,但是又不那么大众化,定位自然就是一个拥有Ioc、Di、Cache、Orm、Rpc的web开发框架.\n技术选型说完了定位来聊聊技术的选型,框架一般来说最重要就那么几个东西,稳定、易用、高性能、可扩展,结合一下几点我们可以筛选出以下几个来.\n\nJava 语言层面毫无疑问它是最满足需求的,比他高性能(c、c++、rust…)的没他简单,比他简单的又没他的性能(js、php…),我个人是偏爱scala的,奈何jvm上和java比除了自己写起来舒服没啥特别优势了.\nVert.x Netty是Jvm上的性能霸主,只要跟性能沾边的就离不开Netty,而Netty过于底层不太适合直接写web框架,最终选用Vert.x(Quarkus,Micronaut封装比Vert.x还是多了些,尽量采用更底层的toolkit而不是现成的framework).\nRedis 无心插柳柳成荫,本意是作为NoSql奈何在缓存方面的光芒掩盖了它本身的定位.\n\n开发环境截止到文章日期,Jdk最新是16,lts长期稳定支持版是11,故我们采用Jdk11.\n\nJdk11\nIdea\nGradle Spring5开始从Maven切到了Gradle,现在新项目没理由用Maven.\n\n命名好的框架从命名开始,复杂难记的框架注定火不起来,经过深思熟虑后框架名为ygo(Yu-Gi-Oh),懂的都懂.\n开搞写框架之前的准备我们都做完了,下一步就来搭建框架的龙骨了.\n","slug":"从零开始撸框架(1)-写在开始之前","date":"2021-04-27T19:27:03.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"}]