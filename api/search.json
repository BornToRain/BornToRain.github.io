[{"id":"1f961444d2b8322d4f975faeb98fbea1","title":"从零开始撸框架(2)-项目龙骨","content":"项目结构上文说到框架包含Ioc、Di、Orm、Cache等功能,其中只有前两者为核心功能.那么结构上可以采用分包结构开发,即分为核心、组件等功能包,如下.\n\norg.btr.ygo.core 核心包,包含了框架ioc、di功能,为其他组件提供支持.\norg.btr.ygo.tp tp意为(third-party),可以将数据库、缓存等需要引入第三方jar的功能放到这.\norg.btr.ygo.web web功能\n\n工厂说到核心Ioc、Di自然离不开工厂模式.我们先准备写工厂会用到的jar\nbuild.gradle\ndependencies &#123;\n  &#x2F;&#x2F; 高性能反射\n  compile &quot;com.esotericsoftware:reflectasm:1.11.9&quot;\n  &#x2F;&#x2F; vertx核心jar\n  compile &quot;io.vertx:vertx-core:$vertxVersion&quot;\n&#125;\n\n辅助类类工厂会经常用到反射,我们需要写几个类来辅助工厂实现.\n\n函数类,这里会存放以后会用到的各种函数式方法.\n\nEnsureSuppliver.java\npackage org.btr.ygo.core.funtions;\n\n/**\n * java8的异常版本\n * @see java.util.function.Supplier\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@FunctionalInterface\npublic interface EnsureSuppliver&lt;T> &#123;\n  T get() throws Exception;\n&#125;\nFn.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Supplier;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic final class Fn &#123;\n  // 连接池函数,优先使用key在池中找可用value,找不到才会通过Supplier去创建一个value.\n  public static &lt;K, V> V pool(Map&lt;K, V> map, K key, Supplier&lt;V> fn) &#123;\n    V value = map.get(key);\n    if (Objects.isNull(value)) &#123;\n      value = fn.get();\n      map.put(key, value);\n    &#125;\n    return value;\n  &#125;\n  // 确保正确运行,这里包含了条件分支.\n  public static &lt;T> T ensureRun(boolean condition, EnsureSuppliver&lt;T> fn1, EnsureSuppliver&lt;T> fn2) &#123;\n    T ret = null;\n    try &#123;\n      if (condition) &#123;\n        if (Objects.nonNull(fn1)) ret = fn1.get();\n      &#125;\n      else &#123;\n        if (Objects.nonNull(fn2)) ret = fn2.get();\n      &#125;\n    &#125; catch (Exception e) &#123;\n      e.printStackTrace();\n    &#125;\n    return ret;\n  &#125;\n&#125;\n\n\n反射类,有关反射的方法都放在这.\n\nReflect.java\npackage org.btr.ygo.core.kit;\n\nimport com.esotericsoftware.reflectasm.ConstructorAccess;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\n\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@SuppressWarnings(\"all\")\npublic final class Reflect &#123;\n  // reflectasm开销主要在于对象的获取,我们把它存起来.\n  private static final Map&lt;Class&lt;?>, ConstructorAccess> CONSTRUCTORS = new HashMap&lt;>();\n  public static &lt;T> T constructor(Class&lt;?> cls, Object... args) &#123;\n    T ret = null;\n    try &#123;\n      val constructors = cls.getDeclaredConstructors();\n      // 拿到类的所有构造函数,我们根据参数来判断选用何种方式创建对象.\n      // 优先使用无参,这样能调用到reflectasm.\n      // 无参不满足就只能走Java原生了.\n      for (Constructor&lt;?> constructor : constructors) &#123;\n        val size = args.length;\n        if (0 == size) ret = noArgConstructor(cls);\n        else if (size != constructor.getParameterTypes().length) continue;\n        ret = (T) constructor.newInstance(args);\n      &#125;\n      return ret;\n    &#125; catch (Exception e) &#123;\n      e.printStackTrace();\n      return ret;\n    &#125;\n  &#125;\n  // 这里用到了reflectasm高性能反射,缺点就是仅支持无参.\n  public static &lt;T> T noArgConstructor(Class&lt;?> cls) &#123;\n    val access = Fn.pool(CONSTRUCTORS, cls, () -> ConstructorAccess.get(cls));\n    return (T) access.newInstance();\n  &#125;\n&#125;\n\n本体Trunk.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\n@SuppressWarnings(\"unchecked\")\npublic final class Trunk &#123;\n  // 单例存储所有类对象\n  private static final Map&lt;String, Object> SINGLETON = new HashMap&lt;>();\n  // 单例,优先读map对象,无则懒加载获取实例并存入map.\n  public static &lt;T> T singleton(Class&lt;?> cls, Object... args) &#123;\n    return (T) Fn.pool(SINGLETON, cls.getName(), () -> instance(cls, args));\n  &#125;\n  // 实例,每调用一次产生一例.\n  public static &lt;T> T instance(Class&lt;?> cls, Object... args) &#123;\n    return Fn\n      .ensureRun(0 == args.length, () -> Reflect.noArgConstructor(cls), () -> Reflect.constructor(cls, args));\n  &#125;\n&#125;\n\n测试TrunkTest.java\npackage org.btr.ygo.core.kit;\n\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.btr.ygo.core.TestApi;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @author &lt;a href=\"mailto:1159930219@qq.com\">BornToRain&lt;/a>\n */\n@Log4j2\npublic class TrunkTest &#123;\n  @Test\n  public void testInstance() &#123;\n    val i1 = Trunk.instance(TestApi.class);\n    val i2 = Trunk.instance(TestApi.class);\n    log.info(\"i1: &#123;&#125;, i2: &#123;&#125;\", i1, i2);\n    Assert.assertNotEquals(i1, i2);\n  &#125;\n  @Test\n  public void testSingleton() &#123;\n    val i1 = Trunk.singleton(TestApi.class);\n    val i2 = Trunk.singleton(TestApi.class);\n    log.info(\"i1: &#123;&#125;, i2: &#123;&#125;\", i1, i2);\n    Assert.assertEquals(i1, i2);\n  &#125;\n&#125;\n\n测试结果\n","slug":"从零开始撸框架(2)-项目龙骨","date":"2021-04-29T02:03:09.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"},{"id":"1da24bfae57d43586cc931d1d18b42d9","title":"奇淫巧技(2)-Jvm篇","content":"函数内联在讲函数内联之前还得讲一个Jvm经常遇到的异常StackOverFlowException,该异常一般翻译成堆栈溢出异常,其实正确或者说更严谨的翻译应该是栈溢出,栈溢出大部分发生在函数的循环或递归调用之中,极少数在对象循环创建中.\n函数调用过程\nJvm栈内存会存储所有热度函数以及它们本地变量和函数.\n新函数调用,新的栈帧加到了栈顶端,分配的本地变量和参数会存储在这.\n跳转到目标函数执行代码.\n函数返回,本地变量和参数都会销毁,栈顶被移除.\n返回原先地址继续执行.\n\n观察调用过程可以看到每次函数调用消耗都比较大,如果放在循环之中不停的重复压栈出栈操作就会导致栈溢出.\n如何优化// 1\nfor (int i = 0; i &lt; list.size(); i++)\n// 2\nfor (int i = 0,j = list.size(); i &lt; j; i++)\n\n\n方式1每次循环都会去调用list来获取他最新的size长度,上面我们已经说到了函数调用的开销,故而方式1会随着循环不断增加开销,此时函数的开销是N.\n方式2只在循环初始化的时候进行了一次函数调用获取size长度并用局部变量保存下来,后面循环开始之后再也没有函数调用开销,此时函数开销始终是1.\n\n如何避免或减少开销这时候就该聊到我们上面提到的函数内联了,它可以显著减少栈帧的创建,多个函数使用一个栈帧来避免栈帧过分.在Jvm中无法人为强行函数内联,只能建议.Jvm是通过函数字节大小以及热度来决定是否内联的,因为我们只要日常代码中满足以下条件即可.\n\n函数字节小于35字节时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxInlineSize=N**来调整内联字节数\n当函数字节小于325字节并且函数是热点时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxFreqInlineSize=N**来调整内联字节数\nJvm自动识别函数热度进行内联,我们也可以通过修改Jvm参数**-XX:CompileThreshold=N**来调整函数热度\n这算是函数内联的隐含条件,编码中多多使用private、static、final来定义函数.如果一个函数没有被外部使用,用这些关键字可以建议Jvm进行内联.,Scala可以直接使用@inline注解来建议Jvm内联.\n\n","slug":"奇淫巧技(2)-Jvm篇","date":"2021-04-28T00:04:30.000Z","categories_index":"奇淫巧技","tags_index":"Jvm","author_index":"因雨而生"},{"id":"91972c9f8cfda280c91f3305c833ffbf","title":"奇淫巧技(1)-Java篇","content":"编码习惯多使用值(val)而不是变量(var)\n变量非线程安全,并发存在读写问题.而值因为其不可修改性天然线程安全无读写问题.多线程开发中值也不用锁,性能更优,程序猿也不用关心多线程下的并发读写锁问题,心智要求大大降低.\n单线程性能也更高,如图.// 1\npublic static int sum() &#123;\n  int a = 2;\n  int b = 3;\n  return a + b;\n&#125;\n// 2\npublic static int sum() &#123;\n  val a = 2;\n  val b = 3;\n  return a + ｂ；\n&#125;\n方式１编译后iconst_2\n// 设置a的值\nistore_0\niconst_3\n// 设置b的值\nistore_1\n// 读取a的值\niload_0\n// 读取b的值\niload_1\niadd\nireturn\n方式2编译后// 常量折叠了,没有访问\"局部变量\"\niconst_5\nireturn\n不过有的场景下值与变量并无二异,比如将上图代码的常量值替换成动态计算的函数// 1\npublic static int sum() &#123;\n  int a = fun1();\n  int b = fun2();\n  return a + b;\n&#125;\n// 2\npublic static int sum() &#123;\n  val a = fun1();\n  val b = fun2();\n  return a + b;\n&#125;\n编译后invokestatic fun1:()I\n// 设置a的值\nistore_0\ninvokestatic fun2:()I\n// 设置b的值\nistore_1\n// 读取a的值\niload_0\n// 读取b的值\niload_1\niadd\nireturn\n\nswitch优化\n工具jarLombokLombok是一个简化Java代码的神兵利器,提供了很多非常实用的注解(并且是非运行时),能减少大量重复代码,其具体实现原理及机制在这不做展开,这里只讲应用.\n\n@Data 常用于开发中的Entity、VO、DTO上,会自动为其属性生成Getter、Setter函数,并覆盖实现了原生的ToString、HashCode、Equals函数.\n@Log4j2、Slf4j 为注解类生成一个日志静态量,名为log.\n@AllArgsConstructor 生成一个全参构造,一般配合构造注入使用.\n@Builder 设计模式中的建造者模式\n@Value 构建一个值对象,即类的属性都是不可变量.\n@Cleanup 自动为IO类型关闭资源.\nval Java9var的常量版本.ex: val i = 1等效于final int i = 1;.\n\nVavrVavr为Java提供了更为强大的Fp支持,虽然比不上其他Fp语言的简单明了,但在Java也算是首屈一指的函数式第三方jar了.\n\nOption(单个数据处理) 相比Optional更加完备\nTry(异常处理)\nValidation(数据校验)\nEither(异常处理)\nFuture(异步处理)\nTuple(元祖类型)\nLazy(惰性求值)\n\n每个函数更具体的信息官方文档都有详细介绍Vavr\n","slug":"奇淫巧技(1)-Java篇 ","date":"2021-04-27T23:20:29.000Z","categories_index":"奇淫巧技","tags_index":"Java,面向函数(FP)","author_index":"因雨而生"},{"id":"f1128ae1167b6a3027acc0aa9f078931","title":"从零开始撸框架(1)-写在开始之前","content":"起因码农日常搬砖中都听说过一句话: 不要重复造轮子(一说是不要造重复的轮子).与公司来说这句话自然是绝对正确的,自研或仿造的轮子往往各方面都不如开源现有的轮子来得好,这样对公司来说无疑是最致命的.但是与个人来说,造轮子的过程同时是阅读他人代码提升自己的过程,而且轮子造完自身也会有种莫名的满足感.\n随着开发的深入,项目需求越来越复杂.市面上一些开源轮子(Spring-boot,Vert.x,Akka)无法满足我们功能需求,自此日常开发中也会采用一些二次轮子(即基于开源轮子再封装一层, ex: Jeecg-boot, Di-boot…各种基于Spring-boot或封装或魔改的轮子).这类二次轮子中维护者或个人或公司,个人的全靠满腔热血,bug反馈以及后期升级堪忧.公司的往往包含多版本(民用、商用、企业)等并且收费不低.关于收费这事我个人看法就是不耻,诚然小部分公司都对这些开源轮子进行了大部分改动,但那总归只是少数.绝大部分都是给开源轮子封了一层皮就敢拿出来卖,这也是前阵子为啥Elastic修改开源协议这档子事.\n回到现在,既然市面上二次轮子也不少.我如今趁着三分钟热度也来造一个轮子未尝不可,只是这次我要和市面上常见的那些妖艳贱货不一样,绝对不会采用一些已经烂大街的技术或框架(当然这并不绝对).这次写下这一系列文章一方面给自己留档,一方面给以后那些想造轮子又找不到方法的朋友参考,这个小白兔有人替你们当了.\n定位所谓定位就是这框架目的是什么,起到什么作用,解决什么问题,适用什么场景,面向什么人员.个人认为对于项目刚启动时候的定位不一定就需要画类图写设计文档,毕竟最初只有雏形概念.我们完全可以把核心概念草稿下来就好,日后再补上类图设计文档也不是问题.\n我们这次框架目的就是造一个类似于Spring-boot的轮子,但是又不那么大众化,定位自然就是一个拥有Ioc、Di、Cache、Orm、Rpc的web开发框架.\n技术选型说完了定位来聊聊技术的选型,框架一般来说最重要就那么几个东西,稳定、易用、高性能、可扩展,结合一下几点我们可以筛选出以下几个来.\n\nJava 语言层面毫无疑问它是最满足需求的,比他高性能(c、c++、rust…)的没他简单,比他简单的又没他的性能(js、php…),我个人是偏爱scala的,奈何jvm上和java比除了自己写起来舒服没啥特别优势了.\nVert.x Netty是Jvm上的性能霸主,只要跟性能沾边的就离不开Netty,而Netty过于底层不太适合直接写web框架,最终选用Vert.x(Quarkus,Micronaut封装比Vert.x还是多了些,尽量采用更底层的toolkit而不是现成的framework).\nRedis 无心插柳柳成荫,本意是作为NoSql奈何在缓存方面的光芒掩盖了它本身的定位.\n\n开发环境截止到文章日期,Jdk最新是16,lts长期稳定支持版是11,故我们采用Jdk11.\n\nJdk11\nIdea\nGradle Spring5开始从Maven切到了Gradle,现在新项目没理由用Maven.\n\n命名好的框架从命名开始,复杂难记的框架注定火不起来,经过深思熟虑后框架名为ygo(Yu-Gi-Oh),懂的都懂.\n开搞写框架之前的准备我们都做完了,下一步就来搭建框架的龙骨了.\n","slug":"从零开始撸框架(1)-写在开始之前","date":"2021-04-27T19:27:03.000Z","categories_index":"从零开始","tags_index":"Vert.x,Actor,设计模式,Java","author_index":"因雨而生"}]