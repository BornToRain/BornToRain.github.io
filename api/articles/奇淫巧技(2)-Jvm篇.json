{"title":"奇淫巧技(2)-Jvm篇","uid":"1da24bfae57d43586cc931d1d18b42d9","slug":"奇淫巧技(2)-Jvm篇","date":"2021-04-27T23:20:29.000Z","updated":"2021-04-28T02:14:08.169Z","comments":true,"path":"api/articles/奇淫巧技(2)-Jvm篇.json","keywords":["Coder","Scalaer","Javaer"],"cover":"/images/javalogo.png","content":"<h2 id=\"函数内联\"><a href=\"#函数内联\" class=\"headerlink\" title=\"函数内联\"></a>函数内联</h2><p>在讲函数内联之前还得讲一个Jvm经常遇到的异常<strong>StackOverFlowException</strong>,该异常一般翻译成堆栈溢出异常,其实正确或者说更严谨的翻译应该是栈溢出,栈溢出大部分发生在函数的循环或递归调用之中,极少数在对象循环创建中.</p>\n<h3 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h3><ol>\n<li>Jvm栈内存会存储所有热度函数以及它们本地变量和函数.</li>\n<li>新函数调用,新的栈帧加到了栈顶端,分配的本地变量和参数会存储在这.</li>\n<li>跳转到目标函数执行代码.</li>\n<li>函数返回,本地变量和参数都会销毁,栈顶被移除.</li>\n<li>返回原先地址继续执行.</li>\n</ol>\n<p>观察调用过程可以看到每次函数调用消耗都比较大,如果放在循环之中不停的重复压栈出栈操作就会导致栈溢出.</p>\n<h3 id=\"如何优化\"><a href=\"#如何优化\" class=\"headerlink\" title=\"如何优化\"></a>如何优化</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 1</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 2</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>j <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>方式1每次循环都会去调用list来获取他最新的size长度,上面我们已经说到了函数调用的开销,故而方式1会随着循环不断增加开销,此时函数的开销是N.</li>\n<li>方式2只在循环初始化的时候进行了一次函数调用获取size长度并用局部变量保存下来,后面循环开始之后再也没有函数调用开销,此时函数开销始终是1.</li>\n</ol>\n<h3 id=\"如何避免或减少开销\"><a href=\"#如何避免或减少开销\" class=\"headerlink\" title=\"如何避免或减少开销\"></a>如何避免或减少开销</h3><p>这时候就该聊到我们上面提到的函数内联了,它可以显著减少栈帧的创建,多个函数使用一个栈帧来避免栈帧过分.在Jvm中无法人为强行函数内联,只能建议.Jvm是通过函数字节大小以及热度来决定是否内联的,因为我们只要日常代码中满足以下条件即可.</p>\n<ol>\n<li>函数字节小于35字节时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxInlineSize=N**来调整内联字节数</li>\n<li>当函数字节小于325字节并且函数是热点时,Jvm会自动内联优化,我们也可以通过修改Jvm参数**-XX:MaxFreqInlineSize=N**来调整内联字节数</li>\n<li>Jvm自动识别函数热度进行内联,我们也可以通过修改Jvm参数**-XX:CompileThreshold=N**来调整函数热度</li>\n<li>这算是函数内联的隐含条件,编码中多多使用private、static、final来定义函数.如果一个函数没有被外部使用,用这些关键字可以建议Jvm进行内联.,Scala可以直接使用@inline注解来建议Jvm内联.</li>\n</ol>\n","feature":null,"text":"函数内联在讲函数内联之前还得讲一个Jvm经常遇到的异常StackOverFlowException,该异常一般翻译成堆栈溢出异常,其实正确或者说更严谨的翻译应该是栈溢出,栈溢出大部分发生在函数的循环或递归调用之中,极少数在对象循环创建中. 函数调用过程 Jvm栈内存会存储所有热度...","link":"","photos":[],"count_time":{"symbolsCount":995,"symbolsTime":"1 mins."},"categories":[{"name":"奇淫巧技","slug":"奇淫巧技","count":2,"path":"api/categories/奇淫巧技.json"}],"tags":[{"name":"Jvm","slug":"Jvm","count":1,"path":"api/tags/Jvm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94\"><span class=\"toc-text\">函数内联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">函数调用过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">如何优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%88%96%E5%87%8F%E5%B0%91%E5%BC%80%E9%94%80\"><span class=\"toc-text\">如何避免或减少开销</span></a></li></ol></li></ol>","author":{"name":"因雨而生","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"一直没脱离低级趣味的Coder","socials":{"github":"https://github.com/BornToRain","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"奇淫巧技(1)-Java篇","uid":"91972c9f8cfda280c91f3305c833ffbf","slug":"奇淫巧技(1)-Java篇 ","date":"2021-04-27T23:20:29.000Z","updated":"2021-04-28T02:08:14.834Z","comments":true,"path":"api/articles/奇淫巧技(1)-Java篇 .json","keywords":["Coder","Scalaer","Javaer"],"cover":"/images/javalogo.png","text":"编码习惯多使用值(val)而不是变量(var) 变量非线程安全,并发存在读写问题.而值因为其不可修改性天然线程安全无读写问题.多线程开发中值也不用锁,性能更优,程序猿也不用关心多线程下的并发读写锁问题,心智要求大大降低. 单线程性能也更高,如图.// 1 public stati...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"奇淫巧技","slug":"奇淫巧技","count":2,"path":"api/categories/奇淫巧技.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"面向函数(FP)","slug":"面向函数-FP","count":1,"path":"api/tags/面向函数-FP.json"}],"author":{"name":"因雨而生","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"一直没脱离低级趣味的Coder","socials":{"github":"https://github.com/BornToRain","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}